<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客终于搭起来了</title>
    <url>/2022/08/06/%E5%8D%9A%E5%AE%A2%E7%BB%88%E4%BA%8E%E6%90%AD%E8%B5%B7%E6%9D%A5%E4%BA%86/</url>
    <content><![CDATA[<p>刚想码字，才发现自己用的NexT主题是旧版本，还奇怪为什么7k+
star的项目为什么文档都不全。 <span id="more"></span>
建这个博客的目的是记录生活和折腾的技术，算是一个比较正式？的个人网站，也想加上GitHub和LinkedIn的链接。</p>
<p>昨天晚上找了一整晚的主题，但是没有找到满意的。Hexo官网的theme列表里有很多展示页面都失效了，也有很多很久没有维护了，不过最主要的还是项目没有很好的文档让人容易上手。以前也用过一个二次元的主题，昨天晚上也找到了另一个，不过可能是人老了，想弄个简洁一点的，不想每篇文章都来个二次元图封面。</p>
<p>今天早上起来准备用昨天发现的主题凑合，顺手搜了一下自己star的的项目，突然看到自己以前star了一个Hexo主题NexT。好家伙，这不正好是我想要的，可是为什么这个7k+
star的项目文档只有一页，也没有详细讲怎么配置主题。自己摸索了一下，大概搞懂怎么配置了。但是因为要动主题的config文件，考虑到以后主题可能还要更新，就先fork了一下，然后自己新建了个branch做修改。虽然麻烦但是也学到了fork的项目怎么跟源项目同步，还学了下把主题项目变成了博客项目的submodule。</p>
<p>但是还是觉得很奇怪为什么昨天晚上没在Hexo官网的theme列表里看到NexT主题，热度这么高不应该没有啊。一搜名字还真有，而且跟我用的还不是同一个项目。到Issue里看了下“必读”才发现原来我用的是旧版，现在看的这个是最新版的，而且配置方法也跟原来不一样了，看来又要重新弄主题了。但是这俩长得也太像了，好歹在旧版也提示一下嘛。
- 新版：https://github.com/next-theme/hexo-theme-next -
旧版：https://github.com/theme-next/hexo-theme-next</p>
<p>不过现在的博客也还没完全配置好，比如之后要写带图片的文章，还要配置一下assets。评论工具也还没有设置。总之慢慢来吧。</p>
<p>上面也提到自己以前也用过GitHub搭过博客，不过都不长久。具体的时间已经记不清了，不过在本科的时候应该是第一次，可能是在上软工课的时候产生的想法？第二次应该是硕士第一年为了找工作能写在简历上？虽然最后都因为学习很忙不了了之。除了GitHub还用过CSDN的博客记了一点东西，不过没啥太大的价值，虽然大三暑假找实习的时候也确实写进简历里了（应该庆幸没有细问我hhh）。</p>
<p>之前用Hexo，都很心急，文档也没有好好看过，也没有耐心去解决配置过过程中遇到的问题。现在至少能耐下性子看文档了，遇到问题也有时间去想办法解决。这次应该会长久一些吧，还是不立flag了。但是学生生涯大概终于是要结束了，给毕设professor打工的内容也基本做完了，下周开始就是我最后的暑假。是得好好休息一下，已经两年没有休过将近一个月的假期了。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>欧洲硕士申请经历</title>
    <url>/2020/08/30/%E6%AC%A7%E6%B4%B2%E7%A1%95%E5%A3%AB%E7%94%B3%E8%AF%B7%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<p>这几篇文章原本是发在B站的，在知乎专栏也备份了，当时B站正好在搞暑期专栏的活动，写了还有点钱拿。虽然最后也就几块钱，但是至少给了我一点点写这几篇总结的动力。后来清B站动态的时候把B站的专栏也删了。现在这些文章已经过了有些时间了，内容也仅供大家参考。</p>
<span id="more"></span>
<h1 id="篇一-欧洲大陆及北欧留学-计算机科学硕士申请经历">篇一
欧洲大陆及北欧留学 计算机科学硕士申请经历</h1>
<p>想着事情办得差不多了就总结一下申请经历的，b站现在正好有暑期活动，那就试试b站专栏吧。这一片会是背景+简介（画大饼），之后会分几篇细讲。</p>
<p>出国留学大概是我一直以来为数不多的执念吧，若不是如此，很可能就经受不住诱惑选保研了。四年前高考成绩大概能上个末流985，也过了大连理工的自主招生，最后来到了双非野鸡南科大。</p>
<p>为什么要申请欧洲（不包括英国，下同）呢，主要是因为自己太菜，想着避免跟大佬们竞争北美申请，英联邦国家学费也有点贵，然后偶然听到学长分享欧洲申请经验成为我申请欧洲的契机。</p>
<p>首先说一下语言问题。欧洲也是有很多英文硕士项目的，并不一定需要小语种成绩。另外雅思和托福都是可以的，并不存在哪个比哪个更好，不过可能考到同样等级的分数难度不同？部分学校也会要求GRE成绩。可能有同学会问要考多少分才够，这个真的是看各个学校的要求，如果你目标学校很明确，那就以学校的要求为目标，如果是跟我一样比较佛系的同学，可以先把目标订到一个不会因为语言方面吃亏的成绩，比如托福100+，GRE
325。</p>
<p>英语当然是越早考越好，但是托福现在只有两年有效期，所以最好是在大二暑假或者大三寒假考托福，大三暑我们就要实习，不知道其他学校是否也是类似的安排。GRE有五年有效期，可以更早考。</p>
<p>时间线大概就是从现在这个时候，大四上学期开始准备申请材料，如简历、动机信会在这个过程中反复修改，还要联系好老师写推荐信，大概十月十一月就可以递交申请材料了。像荷兰出结果比较早的，年底就出录取结果了；德国是比较晚的，有的学校会到第二年七八月份。</p>
<p>我申请的学校所在的国家包括荷兰、比利时、德国、瑞士、丹麦、瑞典。本来准备主申德国（因为不要学费），也找了留学中介，后来变成中介帮忙申请荷兰、德国、瑞士了。德国学校官网实在是劝退国际生，很多英文页面都不完整，很多重要文件只有德语，确实需要中介帮帮忙。德国还有比较麻烦的一点就是需要APS（留德人员审核部）审核，这个后面再说。总的来说德国自己申请的话有点麻烦。相比之下瑞士和荷兰要好很多，所有信息在官网上都能找到英文版的。</p>
<p>北欧的丹麦瑞典，申请操作都不复杂，英文支持很好，完全可以自己搞定。瑞典有个申请系统，可以填四个志愿，不过一般申请某学校奖学金都要求把那所学校设置第一志愿。比利时是我最后才申请的，本来没想着要去的，结果最后去了比利时，比利时同样也要APS。</p>
<p>以上内容仅为个人经验，仅供参考，欢迎批评指正。下一篇应该会是讲申请材料的准备，比如简历、课程描述（课程简介）、推荐信、动机信……</p>
<h1 id="篇二-欧洲大陆及北欧留学-计算机科学硕士申请经历申请材料篇">篇二
欧洲大陆及北欧留学 计算机科学硕士申请经历——申请材料篇</h1>
<p>具体而言，我申请了荷兰的University of Twente，VU
Amsterdam，德国的University of Stuttgart，RWTH
Aachen，瑞士的ETHz和EPFL，丹麦的University of Copenhagen，瑞典的Chalmers
University of Technology，Uppsala
University（虽然瑞典可以填四个不过后面两个基本不用看了），以及比利时的KU
Leuven。除了瑞士的两所学校太难了，没有被录取；其他学校（瑞典录取第一志愿也就是Chalmers，之后的志愿就不会被录取了）都录取了，然而并没有拿到任何一所学校奖学金。</p>
<p>如果没有奖学金，那么我考虑的就只有德国和比利时的学校了，德国除了巴登符腾堡州的学校收学费，其他州都不收学费，斯图加特大学（University
of
Stuttgart）正好在巴符州。但是收学费也不高，一年3000欧元；其次是比利时的荷语区鲁汶大学（KU
Leuven），我的专业学费是6000欧元一年，是的，不同专业学费不一样。</p>
<p>虽然亚琛工大（RWTH
Aachen）录取了，但是我的GRE写作没有达到录取要求，而我又不想再考，也就作罢。就在我接受斯图加特大学的录取之后没多久，鲁汶就给我发邮件说给我免去第一学年的部分学费，只用交不到1000欧，于是最后决定去鲁汶。当然这里我的情况是德国和比利时都要APS，我最初是申请的德国的APS审核，最后转换成了比利时的APS程序，这个放到APS那篇细说吧。</p>
<p>根据我申请的经历，不同学校要求的材料大同小异，具体的要求可以去学校官网查找，这里我列出我在申请时都要用到的材料：
简历，成绩单，在读证明，课程简介（课程描述），动机信，推荐信。</p>
<h2 id="简历">简历</h2>
<p>有的学校材料要求比较细致，比如简历上教育经历要从高中开始写起、时间顺序按照从近到远。我是从网上找的latex模板做的简历，很简洁</p>
<figure>
<img src="1659965770148.png" alt="简历" />
<figcaption aria-hidden="true">简历</figcaption>
</figure>
<p>我没做过什么好的项目，也没有什么好的实习经历，让大家见笑了。不要怕，往上写就完事儿了，大部分人不都是普普通通的嘛，我甚至把一些课程project都写上去了。</p>
<h2 id="成绩单在读证明课程描述">成绩单、在读证明、课程描述</h2>
<p>成绩单和在读证明都由学校开具，我们学校比较好的就是这两个盖章的中英文文件都能直接在机器上打印出来。难的是课程描述，学校虽然有给，但是一堆pdf，我还得从里边找到我成绩单上的课，一个个复制出来，虽然给了英文版，但是那翻译质量实在是太差。在找学校相关部门盖章的时候，也出了些小问题，学校说只能盖章一次，但是我申请不同的学校对课程描述的要求是不一样的，最后通过系里盖章才解决（但是因为我改过一些课程描述的英文，系秘书还问我为什么跟学校给的不太一样）。</p>
<h2 id="动机信">动机信</h2>
<p>动机信花了我很长时间，写写改改，虽然给不同学校的动机信不一样，但是一旦第一篇写下来了，后面就比较顺了。我们学校另一个比较好的地方是语言中心可以免费辅导修改文书，外教和其他老师给了我很多修改建议。在拿去给老师看之前自己先用Grammarly这种语法检查工具自查一下。怎么写动机信呢，这方面德国学术交流中心（DAAD）可以说是很贴心了，我在网上搜到了他们的一篇指导写动机信的文章
(http://ic.daad.de/imperia/md/content/islamabad/letter_of_motivation.pdf)
比如问自己一些问题——自己的专业目标是什么？以你的所学所知，将来准备如何为社会、国家做出贡献？为什么要选这个学校和这个项目？为什么你是这个项目合适的人选？等等。</p>
<h2 id="推荐信">推荐信</h2>
<p>找谁给我写推荐信，当时可难了我一阵，虽然前辈们都说过要今早跟老师多打交道，但是不到时候是认识不到重要性的。最后我勉强凑到了三位老师，两位是指导过我做创新实验的，还有一位名义上是我的书院导师，实际上平时不会怎么打交道（因人而异，有的书院导师经常和他们的学生见面）。虽然是找老师给我写推荐信，实际上都是我自己写然后让他们签个名。所以怎么写呢？</p>
<p>实事求是地夸，不要写负面内容。什么某某是我见过的最优秀的学生之一这种话就不要了（如果是真的那当我没说），我的套路就是做过什么事，体现了什么品质，这些事一定是你做过的，一定是老师可以知道的。比如我在选某导师做创新实验，做项目时遇到了什么问题，如何解决问题，体现了我什么样的能力和品质；如果只是上过某老师的课，我就写我在实验课上做过什么，课程project做得怎么样之类的。</p>
<p>这也要感谢一下书院导师，当时找他写推荐信的时候，他就很明确的跟我说了，你们写的时候，要考虑一下老师的视角，他能知道你哪些方面，不可能知道你哪些方面，这样写出来才比较真实。</p>
<h2 id="ending">Ending</h2>
<p>那么这篇就写到这里，下一篇大概是介绍一下APS。</p>
<h1 id="篇三-德国比利时计算机硕士申请经历aps篇">篇三
德国/比利时计算机硕士申请经历——APS篇</h1>
<p>先给出APS官网 https://www.aps.org.cn
，所有重要信息都可以在网站找到。</p>
<p>申请德国和德国周边的几个国家——比利时、奥地利、瑞士，都可能需要APS审核。APS审核简单来说就是考察你是不是真的学到了你修读专业的相关知识，帮德国那边的高校先筛选一下。所以平时在学校扎实学习的话APS审核并不难，但是需要复习。</p>
<p>APS审核首先是审核你提交的个人信息等材料，之后会通知何时去面谈，大都是去北京，上海也有。面谈也有两步，笔试和面试。从提交材料到面谈，我大概等了一个半月。我是去年7月8日注册的审核部账户，7月19号审核部提醒要补交材料，7月22号通知我在8月12日早上八点去审核部面谈。据中介说我这个速度算是很快了。</p>
<figure>
<img src="1659968357452.png" alt="面谈通知" />
<figcaption aria-hidden="true">面谈通知</figcaption>
</figure>
<p>不能改时间，╮(╯▽╰)╭</p>
<p>到了审核部，会先让你在候考室等，填回寄的快递单，等工作人员叫你的名字。笔试大概十多分钟，我当时只有一道题，因为有规定我不能透露题目，题目是开放式的讨论。然后面试官会带你去面试的房间，和你做的题目一起，面试也会问笔试的内容。</p>
<p>我面试的时候，面试官是一位年轻人和一位老教授，年轻人负责记录，主要是老教授和我互动。面试的时候摆出了我的成绩单，主要考察内容是我近两个学期学的专业课，不过是对方认为的专业课。比如我在那个学期选了电路基础，虽然也算是我们专业选修课，但是这很明显跟计算机隔得很远，我又正好没有怎么准备，结果他问到了，很尴尬，没说出什么东西来。</p>
<p>那么要怎么准备APS面谈呢？首先把成绩单拿出来，把专业相关课程拎出来，做两个文档:一个是用一段话讲一门课学了哪些内容，另一个是列出每门课重要的知识点，最好能举出应用的例子；如果有实验课，也要准备讲实验课做了什么。之所以要联系实际，是因为这个考察并不是考你死记硬背的能力，人家官网也说了：</p>
<figure>
<img src="1659968435885.png" alt="小提示" />
<figcaption aria-hidden="true">小提示</figcaption>
</figure>
<p>当然不要随便扯，扯到你自己也不太熟的东西，面试官再往下问就GG了。准备的这两个文档就是对应提示里面的要求，所以在面试之前熟记它们，能够流利清楚的表达出来就OK。</p>
<p>之前的文章也提到过，我开始申请的是德国的APS证书，后来转成了比利时的。其实我原本也不知道这个能不能转换。首先问了学校，第一次给我答复是学校可以帮忙办转换，第二次却又说要我问本地的审核部。于是我又发邮件问北京的审核部。因为没有收到回复，我连续几天发邮件给他们，在第五天的时候才终于收到回复了，说可以转换，要多交500RMB费用，但是要等我拿到毕业证学位证——因为我之前办的是六个学期的APS证书，现在我的状态当然已经不是六个学期了，所以就直接连着补审一起办了。</p>
<p>荷语区鲁汶是在荷语区，如果是法语区的情况可能就不一样了，总之发邮件问审核部，如果不回信就多发几封。</p>
<p>下一篇可能大概是办签证的过程？</p>
<h1 id="篇四-比利时硕士留学申请经历签证申请篇">篇四
比利时硕士留学申请经历——签证申请篇</h1>
<p>回家大概有两个月了，竟然就已经忘了具体哪天从学校回来了。翻了翻火车票，没找到，最后在支付宝账单的公交车支付记录查到是7月8号回家，然后才想起那天火车晚点七个小时；那段时间水灾严重，本来早上四五点就应该到了，列车慢慢悠悠晃到中午才到武汉。</p>
<p>比利时留学的签证申请还分是公立学校还是私立学校，分别对应有不同的条款，我即将去的学校KU
Leuven是公立大学，所以这里的经验也只适用于公立学校。比利时签证申请在国内是由VFS签证中心办理，详细的信息都可以在VFS网站
(https://www.vfsglobal.cn/Belgium/China/Chinese/study.html)
上查到，比如申请公立大学要提交的材料：https://www.vfsglobal.cn/Belgium/China/Chinese/pdf/student-art-fifty-eight-cn.pdf
。要注意这些资料随时都可能发生变化，在我准备的过程中就看到这个文档变过一次了。</p>
<p>下面就说一下我觉得比较重要的几个材料：体检证明、无犯罪记录、资金证明。</p>
<p>我发过邮件问签证中心，体检只能去指定医疗机构（具体哪些在上面链接的文档里有提及），都是些私立机构，收费自然有点贵。更坑的是武汉没有指定的机构，还好深圳有。我这是第一次去私立医疗机构，先打电话过去预约，接电话的工作人员上来就是英语，我完全没有心理准备，直接就懵了，磕磕巴巴半天没说出啥来，然后工作人员问了句：可以用中文吗？</p>
<p>我在6月30号去体检，收了720；三个工作日之内拿到结果，可以邮寄到付，我就直接填了家里的地址。体检不用空腹，拍了胸片，抽了一管血；最后看到结果，原来是测了艾滋病和梅毒。体检报告上面中英文都有，拿到是可以直接用的，不用再办翻译公证。有一说一，不愧是私立医疗机构，环境和服务真的好。</p>
<p>无犯罪记录，需要双认证——除了要翻译公证，还要我们国家的外交部和比利时大使馆的认证。所以材料会寄到北京，整个过程大概一个月。根据我之前在网上查到的信息，各地办理流程好像稍微有点区别。</p>
<p>我是先到我家附近的公证处拿了一个申请函件，然后到公安局去办证明，也就是填函件上的信息和盖章。在公安局发生了点小插曲，民警说格式要按照他们的来，商量了半天才同意按照公证处给的格式，但是要我们先自己打印好那个模板。因为公证处给的函件上面有抬头，公证处特地划掉了，就是想让公安局出具没有抬头的，比利时无犯罪记录认证要求<strong>不能有抬头</strong>。</p>
<figure>
<img src="1659969414553.jpg" alt="picture 4" />
<figcaption aria-hidden="true">picture 4</figcaption>
</figure>
<p>也就是我回家当天，即使是经过了一晚上加一早上的卧铺，还是当天就去公证处办了。7月8号提交，8月7号才收到，还真的就花了一个月。在这期间我还把德国的APS证书补审加转换成比利时荷语区的APS证书，申请了学校的资金证明。</p>
<p>KU
Leuven学校比较大，提供资金证明的服务，我只需要打九千多欧元钱到学校指定账户，过几天学校就发了一份资金证明pdf到我邮箱，顺便告知我录取通知和资金证明都已经发给了比利时驻华大使馆。但是我也看到群里有人说他们学校没有这个服务，只能通过担保人这种方式提供资金证明，金额要求好像比较高。</p>
<p>拿到无犯罪记录的双认证，APS转换做好，其他材料也准备好了，终于可以去签证中心办签证了。然而武汉本来有签证中心，因为疫情关闭之后就一直没开，我只能去最近的长沙签证中心。同样也是电话预约，8月12日上午去提交材料，为了剩下一晚上的住宿费，我坐凌晨一点半左右的火车去长沙，将近凌晨五点到，然后一直等到早上九点签证中心开门。</p>
<p>下签证倒是挺快，8月22日就收到了签证，一起的还有退回的各种材料一份。</p>
<p>下一篇大概是一些感想和鸡汤？</p>
<h1 id="篇五-欧洲硕士留学申请经历感想与后记">篇五
欧洲硕士留学申请经历——感想与后记</h1>
<p>出国留学的准备是从很早就开始了，最初是打算先参加本校与国外学校学期交流项目，所以在大二寒假就考了第一次托福，因为英语底子还不错第一次就考了100。后来仔细看了合作项目的课程，发现专业课的学期安排和我们学校有些冲突，这条路就没有再继续。</p>
<p>大一下的时候想试试生物，后来又因为对这类专业未来职业发展不太好的言论和不喜欢繁琐的实验记录而退坑，转而跳进了更大的计算机坑；但并不完全因为“计算机好找工作”，而且实际情况是只有当你要找工作的时候就知道并不好找，还因为自己以前就很喜欢折腾软硬件，和对人工智能和自动化的憧憬。</p>
<p>现在看来，可能去做数码产品的评测更适合我，我只不过是喜欢折腾新鲜玩意儿，也就是组合和使用，我并不关心它们怎么被制造出来。从大二开始，学了越来越多计算机知识，在各门课作业中穿梭，也越来越麻木。直到大三要找暑期实习，才发现简直是糟透了。</p>
<p>大三那段时间很焦虑。第一个创新实验做得不顺利，觉得老师和队友都不行，于是换了导师和课题，结果碰上了更坑的队友。当然如果我自己很nb就没有这么多问题了。更因为之前都只是关注成绩和留学申请，根本没想过暑期实习，也完全没有准备，面一个挂一个，搞得整个人精神状态很差。也就是在这种情况下，大三快结束的时候，去找了中介帮忙参考。</p>
<p>有一说一，如果不是因为整个大三混乱的状态，中介是可以省掉的，但是当时实在是力不从心。大四寒假回家，因为疫情被困在家里四个多月，更让我幡然醒悟，在我这种家庭不和睦的环境，本应该优先考虑如何经济独立。可惜大学离家很远，距离让我可以逃避很多烦心事。而另一个让我忽略了优先目标的，大概是大学的气氛——盲目吹捧本科生就进实验室磕盐的气氛；搞得我一度以为自己也应该早早找好导师，进实验室打杂，做实验，发paper；实在是too
young too simple, sometimes naive。</p>
<p>但是以前常常把现在一些窘境归因于过去的自己没有明确目标，也就谈不上规划，现在看来，只是被这大学四年消磨掉了憧憬和热情。并不是给自己的佛系状态找借口，只是在这样有着充分选择自由的大学和又不太自由的家庭两种环境之间，没有谁能够指引前进的方向却又循规蹈矩地度过了这四年。更糟糕的还有这四年慢慢形成的惰性，虽然这种情况我和同学经常互相吐槽。</p>
<p>现在的我大概处于接受事实并且为提高专业水平而努力的状态，转别的专业成本太高，我也并不讨厌写代码。但是实在是觉得自己实践太少，读完了计算机本科，也写不出个像样的软件。不过毕竟不是培训班，可以说这也正常，全靠自己课外花时间了，奈何那时候心里也放不下课程，时间安排也不太行。总之，向前看吧。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>C++ Virtual Keyword and Confusion of a Reference Creation Expression</title>
    <url>/2022/09/19/C-Virtual-Keyword-and-Confusion-of-a-Reference-Creation-Expression/</url>
    <content><![CDATA[<p>For the first week I started my job, I mainly review C++ apart from
those administration matters. There are some tutorials inside company
wiki. When I review the <code>virtual</code> feature of C++, my brain is
a little bit of mess. Also, I meet a confusing expression related with
reference. Therefore, after I figure out what happened exactly, I decide
to write these things for a backup of my memory.</p>
<span id="more"></span>
<h2 id="update">2023-07-23 Update</h2>
<p>前段时间因为试着找国内的工作，看了下C++的面经，正好巩固了些基础知识。当然这十个月的工作中也学了一些C++。现在回过头来看当时的疑惑，其实也就是些基础知识，但是因为没有系统性学C++，所以那时候查起来也有困难。</p>
<p>现在也能给当时的疑惑一个简单的解答了。AClass&amp;
a(anotherObject)，只不过是一种初始化方式，也就是下面的第二种，只不过是初始化一个reference而不是普通的variable：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> a&#123;<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>virtual</code>关键字用来C++实现动态多态。derived
class可以override在base class里使用了virtual关键字的方法。当使用base
class的指针指向一个derived class的实例，就可以调用derived
class里被override的方法了。</p>
<p>virtual特性的一种实现是（大多数编译器也是这么做的）：每一个derived
class要维护一个virtual table，virtual
table里有指向virtual函数的指针。base class有一个virtual table
pointer的属性，指向virtual table。到了调用virtual函数的时候，就从virtual
table里找对应的函数指针。</p>
<p>至于virtual table pointer指向哪个地址，我没有深究，但是猜测是derived
class在初始化的时候会给base class的virtual table
pointer初始化值，指向自己的virtual table。</p>
<h2 id="conclusion">Conclusion</h2>
<p>When not use <code>virtual</code> to try to override a method
(<code>getClassName</code>) in the derived class, as case 2, the pointer
<code>p2base</code> of <strong>parent</strong> class type
(<code>CMyClass</code>) call the method from <strong>its own
class</strong>, NOT the child's (<code>CMyDerivedClass</code>) method,
although <strong>the pointer points to a child class
object</strong>.</p>
<p>After add <code>virtual</code> keyword to the method, the
<code>p2base</code> object pointer calls the child's method. As case 1,
this behavior is intuitive as we expect.</p>
<h2 id="case-1-virtual-keyword-before-the-methods.">Case 1:
<code>virtual</code> keyword before the methods.</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the parent class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyClass</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// some methods</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CMyClass&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the child class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyDerivedClass</span> : <span class="keyword">public</span> CMyClass &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CMyDerivedClass&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMyDerivedClass child;</span><br><span class="line">    </span><br><span class="line">    CMyClass* p2base = &amp;child;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get class name from parent pointer to child.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p2base-&gt;<span class="built_in">getClassName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    CMyDerivedClass* pchild = &amp;child;</span><br><span class="line"></span><br><span class="line">    <span class="function">CMyDerivedClass <span class="title">lv_Test3</span><span class="params">(*pchild)</span></span>;</span><br><span class="line">    <span class="function">CMyClass&amp; <span class="title">lv_Test4</span><span class="params">(*pchild)</span></span>;</span><br><span class="line">    <span class="function">CMyClass <span class="title">lv_Test5</span><span class="params">(*pchild)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;last tests&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lv_Test3: &quot;</span> &lt;&lt; lv_Test3.<span class="built_in">getClassName</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lv_Test4: &quot;</span> &lt;&lt; lv_Test4.<span class="built_in">getClassName</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lv_Test5: &quot;</span> &lt;&lt; lv_Test5.<span class="built_in">getClassName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The running result:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get class name from parent pointer to child.</span><br><span class="line">CMyDerivedClass</span><br><span class="line">last tests</span><br><span class="line">lv_Test3: CMyDerivedClass</span><br><span class="line">lv_Test4: CMyDerivedClass</span><br><span class="line">lv_Test5: CMyClass</span><br></pre></td></tr></table></figure>
<h2 id="case-2-no-virtual-keyword-before-the-methods">Case 2: no
<code>virtual</code> keyword before the methods</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the parent class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyClass</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// some methods</span></span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CMyClass&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the child class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyDerivedClass</span> : <span class="keyword">public</span> CMyClass &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CMyDerivedClass&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The running result:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get class name from parent pointer to child.</span><br><span class="line">CMyClass</span><br><span class="line">last tests</span><br><span class="line">lv_Test3: CMyDerivedClass</span><br><span class="line">lv_Test4: CMyClass</span><br><span class="line">lv_Test5: CMyClass</span><br></pre></td></tr></table></figure>
<h2 id="confusion">Confusion</h2>
<p>I've been confuesd by the expression
<code>CMyClass&amp; lv_Test4(*pchild);</code> for two days. I searched
lots of keywords, copy constructor, copy initialisation, reference
initialisation, base class instantiation from devrived object ...</p>
<p>I thought it would be the same as first create an object of
<code>CMyClass</code> and then create an reference to that object.
Therefore, I tried the following code</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CMyClass <span class="title">cp4Test6</span><span class="params">(child)</span></span>;</span><br><span class="line">CMyClass&amp; lv_Test6 = cp4Test6;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;lv_Test4: &quot;</span> &lt;&lt; lv_Test4.<span class="built_in">getClassName</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;lv_Test6: &quot;</span> &lt;&lt; lv_Test6.<span class="built_in">getClassName</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>Suddenly I came up an idea to check the address of <code>child</code>
and <code>lv_Test4</code> in case 1. It found out that the addresses
were the same.</p>
<p>Therefore, it just created a reference to <code>child</code>.</p>
<h2 id="virtual-override">Virtual, Override</h2>
<p><a
href="https://stackoverflow.com/questions/39932391/should-i-use-virtual-override-or-both-keywords">c++
- Should I use virtual, override, or both keywords? - Stack
Overflow</a></p>
<p>Virtual keyword marks the method in the base class virtual, and the
derived class can override the virtual method in the base class. While
the derived class does not need to use virtual keyword before the
overridden method. If used, it indicates the method can be further
overridden in the further derived class.</p>
<p>The override keyword, only used in the derived class for the method
override.</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
  </entry>
  <entry>
    <title>C++ Miscellaneous</title>
    <url>/2022/09/30/C-Miscellaneous/</url>
    <content><![CDATA[<p>C++ is really complex, though interesting. There are many details and
I think it's not possible to remember all. This post is to record any
useful information I find about C++, and will be kept updating. If there
are topics needed to further explanation, I may write a new post
specific for that.</p>
<span id="more"></span>
<h1 id="c-pointer-and-reference">C++ pointer and reference</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a pointer</span></span><br><span class="line"><span class="type">int</span>* pint = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a reference</span></span><br><span class="line"><span class="type">int</span>&amp; rint = i;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Pointers and References are treated in the same way by the
compiler</p>
</blockquote>
<p>https://stackoverflow.com/questions/11347111/dereferencing-a-pointer-when-passing-by-reference</p>
<p>If created a reference to a variable (not a pointer), then the
address that the reference points to can't be modified, which is not
like a pointer.</p>
<h1 id="c-cast">C++ Cast</h1>
<p><a
href="https://stackoverflow.com/questions/28002/regular-cast-vs-static-cast-vs-dynamic-cast">c++
- Regular cast vs. static_cast vs. dynamic_cast - Stack Overflow</a></p>
<p>Dynamic cast: cast from base class to derived class, but there must
be at least one virtual method in the base class. If trying to cast for
incompatible classes, it fails and returns a null pointer.</p>
<p>Static cast: do not check the compatibility of classes cast (? not
sure, but the following code will run, which cast CB object into CC
object). But will check things like casting an int pointer to a char
pointer, to avoid memory error.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mp_Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;IA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CB</span> : <span class="keyword">public</span> IA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mp_Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CC</span> : <span class="keyword">public</span> IA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mp_Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CC&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gp_SomeFunction</span><span class="params">(IA* arg)</span> </span>&#123;</span><br><span class="line">    arg-&gt;<span class="built_in">mp_Print</span>();</span><br><span class="line">    CB* lv_pCast2CB = <span class="built_in">static_cast</span>&lt;CB*&gt;(arg);</span><br><span class="line">    <span class="keyword">if</span> (lv_pCast2CB) &#123;</span><br><span class="line">        lv_pCast2CB-&gt;<span class="built_in">mp_Print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;null pointer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CB lv_cb;</span><br><span class="line">    <span class="built_in">gp_SomeFunction</span>(&amp;lv_cb);</span><br><span class="line"></span><br><span class="line">    CC lv_cc;</span><br><span class="line">    <span class="built_in">gp_SomeFunction</span>(&amp;lv_cc);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="explicit-constructor">Explicit constructor</h1>
<p><a
href="https://www.geeksforgeeks.org/use-of-explicit-keyword-in-cpp/">Use
of explicit keyword in C++ - GeeksforGeeks</a> To prevent implicit type
conversion for the constructor that can be called with only one
argument</p>
<h1 id="c-standard-terms">C++ Standard Terms</h1>
<p>For this I think might be better to read some books consistent with
C++ standard terms.</p>
<p>It is the first time I know that C++ has defined some terms for OO
concepts: object, subobject, base class, derived class. Understandable
but not the same as usally used in OO programming such as superclass,
parent, child, ....</p>
<p>https://stackoverflow.com/questions/18451683/c-disambiguation-subobject-and-subclass-object</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
  </entry>
  <entry>
    <title>Sync Between Microsoft 365 Outlook and Personal Calendar</title>
    <url>/2022/09/20/Sync-Between-Microsoft-365-Outlook-and-personal-calendar/</url>
    <content><![CDATA[<p>开始工作之后，日程安排也变得更重要了。</p>
<span id="more"></span>
<p>公司用的是企业版microsoft office
365，邮件和日历自然也就是用Outlook。但是登录都只能在公司内网，或者用VPN，想在手机上看还得用公司的iPhone（<del>还不知道咋申请</del>
后来知道了每个员工的岗位对应一个code，不同的code有不同的配置，我的话就没有配置公司的iPhone）。</p>
<p>有些私人的事情比如看医生、去市政厅之类的，也得在工作日的工作时间，所以想加一个统一的日历里，方便日程管理。</p>
<p>在Outlook的Calendar右键菜单看到了可以分享、邮件发送或者publish到WebDav。邮件发送首先可以派出了，因为不能自动同步，每次还得手动导入日程。分享也试过了，要输入分享到哪个邮箱地址，但是输入之后都提示对方的机构没有足够安全的设置所以不能分享。WebDav是我尝试了最久的，昨晚和今早都在找解决方案，Onedrive和坚果云都试过了，都没成功。</p>
<p>最后我在用webdav
calendar的关键词搜索的时候，找到了一个Outlook插件——Outlook CalDav
Synchronizer，可以同步Outlook的日历到自定义的CalDav；但是也有更简单的，同步到谷歌日历。用这个插件成功把公司的Outlook日历同步到了我的个人谷歌日历，而且是双向同步。</p>
<p>这是官网： https://caldavsynchronizer.org/</p>
<p>官网给了几个配置的教程链接，我follow的这个配置成功了，不过配置的是谷歌日历：
https://www.webdavsystem.com/server/access/caldav/ms_outlook_caldav_synchronizer/</p>
<p>这是插件项目的GitHub地址：
https://github.com/aluxnimm/outlookcaldavsynchronizer</p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
  </entry>
  <entry>
    <title>Cpp multi-threading exception on Windows</title>
    <url>/2023/07/23/Cpp-multi-threading-on-exception-Windows/</url>
    <content><![CDATA[<p>在工作的时候遇到了exception如果发生在std::thread里面整个程序会直接崩溃的问题。</p>
<span id="more"></span>
<h1 id="conclusion">Conclusion</h1>
<p>感觉要么自己在thread里处理好exception，或者自己包装一下thread（配合promise使用），要么用更高级的API，可以返回运行结果或者exception。</p>
<h1 id="when-exception-happens-in-a-running-stdthread">When exception
happens in a running std::thread</h1>
<p>if use std::thread, an exception occurs and not catched inside thread
&gt; If no matching handler is found, the function std::terminate() is
called &gt; https://stackoverflow.com/a/7272147 &gt;
https://en.cppreference.com/w/cpp/thread/thread</p>
<p>By default, terminate() will call abort() &gt;
https://cplusplus.com/reference/exception/terminate/</p>
<ul>
<li>cannot catch exception outside the thread where the exception
happens &gt; No you most definitely cannot catch an exception outside of
its "thread or origin". The exception catching depends on stack
unwinding, and stack is fundamentally thread-specific. &gt;
https://stackoverflow.com/a/7272147</li>
</ul>
<p>didn't find a source for "exception catching depends on stack
unwinding"</p>
<ul>
<li>use std::async instead of std::thread &gt;
https://stackoverflow.com/a/7273925 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> run = []() -&gt; T <span class="comment">// T may be void as above</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// may throw</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/* some T */</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> launched = std::<span class="built_in">async</span>(run);</span><br><span class="line"><span class="comment">// launched has type std::future&lt;T&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// may throw here; nothing bad happens</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// expression has type T and may throw</span></span><br><span class="line"><span class="comment">// will throw whatever was originally thrown in run</span></span><br><span class="line">launched.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>this way we can get the exception by <code>launched.get()</code> in
the parent thread. if not call get(), exception will be ignored (I
tested).</p>
<p>However, async() does not guarantee to use a separate thread &gt;
https://en.cppreference.com/w/cpp/thread/async</p>
<ul>
<li>maybe use std::thread with std::promise and std::future, create a
wrapper &gt; https://en.cppreference.com/w/cpp/thread/promise</li>
</ul>
<h1
id="use-threading-api-microsofts-ppl-rather-than-plain-stdthread">Use
Threading API (Microsoft's PPL) rather than plain std::thread</h1>
<blockquote>
<p>https://stackoverflow.com/a/25221591</p>
</blockquote>
<h1 id="stdasync-also-use-ppl-api">std::async also use PPL API?</h1>
<blockquote>
<p>https://stackoverflow.com/a/36914984</p>
</blockquote>
<p>This answer also says <code>concurrency::task</code> has lower
efficiency, compared to self-made thread pool with
<code>std::thread</code> and <code>std::promise</code>.</p>
<p>While, in MS document, it only says async use Windows thread pool,
and non-conforming with C++ standard</p>
<blockquote>
<p>The C++ standard states that if policy is launch::async, the function
creates a new thread. However the Microsoft implementation is currently
non-conforming. It obtains its threads from the Windows ThreadPool,
which in some cases may provide a recycled thread rather than a new one.
This means that the launch::async policy is implemented as
launch::async|launch::deferred. Another implication of the
ThreadPool-based implementation is that there's no guarantee that
thread-local variables will be destroyed when the thread completes. If
the thread is recycled and provided to a new call to async, the old
variables will still exist. We recommend that you don't use thread-local
variables with async.
https://learn.microsoft.com/en-us/cpp/standard-library/future-functions?view=msvc-170#async</p>
</blockquote>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio: PainterResource Exception - Only VectorDrawables and rasterized asset types are supported ex. PNG, JPG</title>
    <url>/2023/09/19/Android-Studio-PainterResource-Exception-Only-VectorDrawables-and-rasterized-asset-types-are-supported-ex-PNG-JPG/</url>
    <content><![CDATA[<p>解决方法：重启Android Studio。</p>
<p>最近想学一下安卓开发，做几个自己想要的应用。上次做安卓app还是在本科毕设的时候，三年多之前了。找到了谷歌官方的安卓开发教程，就跟着做了，结果到引入图片的时候报错了。</p>
<span id="more"></span>
<p>就是在painterResource这里报错：Only VectorDrawables and rasterized
asset types are supported ex. PNG, JPG <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Image(</span><br><span class="line">            painter = painterResource(id = R.drawable.androidparty),</span><br><span class="line">            contentDescription = <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
反复看了几遍官方代码，并没有什么区别。</p>
<p>搜到stackoverflow里有人遇到相同的问题，重启Android Studio然后clean
build，我就试着重启了下，然后就好了，真无语。</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
  </entry>
  <entry>
    <title>Visual Studio CMake Presets添加option</title>
    <url>/2024/05/28/Visual-Studio-CMake-Presets%E6%B7%BB%E5%8A%A0option/</url>
    <content><![CDATA[<p>今天试了试用Visual
Studio打开Qt的CMake项目，但是VS里用CMake的方式好像和Qt
Creator的不一样。</p>
<span id="more"></span>
<p>因为我的项目CMake里有一个自定义的option，在Qt的项目设置里有GUI可以设置那个option，但是在VS里找了一会没找到，而且VS好像是用cmake
presets来设置的，于是问了一下Copilot。
简单来说就是在<code>cacheVariables</code>里加上要设置的option就行了，我这里是<code>BUILD_EXAMPLE</code>。</p>
<p>之后还是得抽空学一学CMake。</p>
<p>以下是copilot的回答。 Certainly! To modify the
<code>CMakePresets.json</code> file and set the
<code>"BUILD_EXAMPLE"</code> option to <code>true</code>, follow these
steps:</p>
<ol type="1">
<li><p>Open the <code>CMakePresets.json</code> file in a text
editor.</p></li>
<li><p>Locate the appropriate configure preset where you want to set the
<code>"BUILD_EXAMPLE"</code> option. In your provided example, we have
two presets: <code>"Qt-Debug"</code> and
<code>"Qt-Release"</code>.</p></li>
<li><p>Add or modify the <code>"cacheVariables"</code> section within
the chosen configure preset. Specifically, add an entry for
<code>"BUILD_EXAMPLE"</code> with the value <code>"ON"</code> (to set it
to true). For example:</p>
<p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Qt-Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;inherits&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Qt-Default&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;binaryDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;sourceDir&#125;/out/build&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cacheVariables&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;CMAKE_BUILD_TYPE&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;CMAKE_CXX_FLAGS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-DQT_QML_DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;BUILD_EXAMPLE&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ON&quot;</span>  <span class="comment">// Add this line</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;QML_DEBUG_ARGS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-qmljsdebugger=file:&#123;908eb81f-69af-44f1-b571-199332c0b484&#125;,block&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Save the modified <code>CMakePresets.json</code> file.</p></li>
</ol>
<p>Remember that <code>CMakePresets.json</code> specifies project-wide
build details, so any changes you make here will affect the entire
project. If you want to customize your local build details, consider
using <code>CMakeUserPresets.json</code> instead⁴. Make sure to follow
best practices for version control, such as ignoring
<code>CMakeUserPresets.json</code> if you're using Git.</p>
<p>Feel free to adjust other settings in the presets as needed for your
project! 😊</p>
<p>源: 与 Copilot 的对话， 2024/5/28 (1) cmake-presets(7) — CMake 3.29.3
Documentation.
https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html. (2)
CMake Presets integration in Visual Studio and Visual Studio Code.
https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/.
(3) Build and Configure CMake Projects With CMakePresets.
https://www.youtube.com/watch?v=vKUaWxemtWI. (4) Simplified CMake
Tutorial. https://www.youtube.com/watch?v=mKZ-i-UfGgQ. (5) CMake presets
| CLion Documentation - JetBrains.
https://www.jetbrains.com/help/clion/cmake-presets.html. (6) Configure
and build with CMake Presets | Microsoft Learn.
https://learn.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-170.</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>WebDAV用到的XML的一些概念</title>
    <url>/2024/05/22/WebDAV%E7%94%A8%E5%88%B0%E7%9A%84XML%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>最近在做跟WebDAV有关的个人项目，WebDAV协议里有一部分HTTP
method的body需要用到xml，就查了些不熟的概念，copy到这里放在一起方便看。</p>
<span id="more"></span>
<h1 id="xml-element">XML Element</h1>
<h2 id="what-is-an-xml-element">What is an XML Element?</h2>
<p>An XML element is everything from (including) the element's start tag
to (including) the element's end tag.<br />
<code>&lt;price&gt;29.99&lt;/price&gt;</code></p>
<p>An element can contain:</p>
<ul>
<li>text</li>
<li>attributes</li>
<li>other elements</li>
<li>or a mix of the above</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;children&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;web&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>In the example above:</p>
<p><code>&lt;title&gt;</code>, <code>&lt;author&gt;</code>,
<code>&lt;year&gt;</code>, and <code>&lt;price&gt;</code> have
<strong>text content</strong> because they contain text (like
<code>29.99</code>).</p>
<p><code>&lt;bookstore&gt;</code> and <code>&lt;book&gt;</code> have
<strong>element contents</strong>, because they contain elements.</p>
<p><code>&lt;book&gt;</code> has an <strong>attribute</strong>
(<code>category="children"</code>).</p>
<h2 id="empty-xml-elements">Empty XML Elements</h2>
<p>An element with no content is said to be empty.</p>
<p>In XML, you can indicate an empty element like this:<br />
<code>&lt;element&gt;&lt;/element&gt;</code></p>
<p>You can also use a so called self-closing tag:<br />
<code>&lt;element /&gt;</code></p>
<p>The two forms produce identical results in XML software (Readers,
Parsers, Browsers).</p>
<p>Empty elements can have attributes.</p>
<h1 id="namespace">Namespace</h1>
<h2 id="solving-the-name-conflict-using-a-prefix">Solving the Name
Conflict Using a Prefix</h2>
<p>Name conflicts in XML can easily be avoided using a name prefix.</p>
<p>This XML carries information about an HTML table, and a piece of
furniture:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h:table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h:tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h:td</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">h:td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h:td</span>&gt;</span>Bananas<span class="tag">&lt;/<span class="name">h:td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h:tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h:table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">f:table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">f:name</span>&gt;</span>African Coffee Table<span class="tag">&lt;/<span class="name">f:name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">f:width</span>&gt;</span>80<span class="tag">&lt;/<span class="name">f:width</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">f:length</span>&gt;</span>120<span class="tag">&lt;/<span class="name">f:length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">f:table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>In the example above, there will be no conflict because the two
<code>&lt;table&gt;</code> elements have different names.</p>
<h3 id="local-name">Local Name</h3>
<p>the element's actual name within the namespace, for example in
<code>&lt;h:table&gt;</code>, <code>table</code> is the local name</p>
<h2 id="xml-namespaces---the-xmlns-attribute">XML Namespaces - The xmlns
Attribute</h2>
<p>When using prefixes in XML, a namespace for the prefix must be
defined.</p>
<p>The namespace can be defined by an xmlns attribute in the start tag
of an element.</p>
<p>The namespace declaration has the following syntax.
xmlns:prefix="URI".</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h:table</span> <span class="attr">xmlns:h</span>=<span class="string">&quot;http://www.w3.org/TR/html4/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h:tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h:td</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">h:td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h:td</span>&gt;</span>Bananas<span class="tag">&lt;/<span class="name">h:td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h:tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h:table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">f:table</span> <span class="attr">xmlns:f</span>=<span class="string">&quot;https://www.w3schools.com/furniture&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">f:name</span>&gt;</span>African Coffee Table<span class="tag">&lt;/<span class="name">f:name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">f:width</span>&gt;</span>80<span class="tag">&lt;/<span class="name">f:width</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">f:length</span>&gt;</span>120<span class="tag">&lt;/<span class="name">f:length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">f:table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>In the example above:</p>
<p>The xmlns attribute in the first <code>&lt;table&gt;</code> element
gives the <code>h:</code> prefix a qualified namespace.</p>
<p>The xmlns attribute in the second <code>&lt;table&gt;</code> element
gives the <code>f:</code> prefix a qualified namespace.</p>
<p>When a namespace is defined for an element, all child elements with
the same prefix are associated with the same namespace.</p>
<p>Namespaces can also be declared in the XML root element:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">xmlns:h</span>=<span class="string">&quot;http://www.w3.org/TR/html4/&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:f</span>=<span class="string">&quot;https://www.w3schools.com/furniture&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h:table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h:tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h:td</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">h:td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h:td</span>&gt;</span>Bananas<span class="tag">&lt;/<span class="name">h:td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h:tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h:table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">f:table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">f:name</span>&gt;</span>African Coffee Table<span class="tag">&lt;/<span class="name">f:name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">f:width</span>&gt;</span>80<span class="tag">&lt;/<span class="name">f:width</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">f:length</span>&gt;</span>120<span class="tag">&lt;/<span class="name">f:length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">f:table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Note: The namespace URI <strong>is not used by the parser to look up
information</strong>.</p>
<p>The purpose of using an URI is to give the namespace a unique
name.</p>
<p>However, companies often use the namespace as a pointer to a web page
containing namespace information.</p>
<h2 id="uniform-resource-identifier-uri">Uniform Resource Identifier
(URI)</h2>
<p>A Uniform Resource Identifier (URI) is a string of characters which
identifies an Internet Resource.</p>
<p>The most common URI is the Uniform Resource Locator (URL) which
identifies an Internet domain address. Another, not so common type of
URI is the Uniform Resource Name (URN).</p>
<h2 id="default-namespaces">Default Namespaces</h2>
<p>Defining a default namespace for an element saves us from using
prefixes in all the child elements. It has the following syntax:<br />
<code>xmlns="namespaceURI"</code></p>
<p>This XML carries HTML table information:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/TR/html4/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bananas<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>This XML carries information about a piece of furniture:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://www.w3schools.com/furniture&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>African Coffee Table<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">width</span>&gt;</span>80<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">length</span>&gt;</span>120<span class="tag">&lt;/<span class="name">length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>copy from: https://www.w3schools.com/</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>在Item View里画一个checkbox并能改变勾选状态 - subclassing QStyledItemDelegate</title>
    <url>/2024/06/03/%E5%9C%A8Item-View%E9%87%8C%E7%94%BB%E4%B8%80%E4%B8%AAcheckbox%E5%B9%B6%E8%83%BD%E6%94%B9%E5%8F%98%E5%8B%BE%E9%80%89%E7%8A%B6%E6%80%81-subclassing-QStyledItemDelegate/</url>
    <content><![CDATA[<p>最近在用Qt做一个hobby project，类似Microsoft Todo的任务清单。</p>
<span id="more"></span>
<p>最初就是用QListView，QStandardItemModel，QStandardItem，和默认使用的QStyledItemDelegate。如果每个只是显示任务名字和一个checkbox的话，这些确实足够了。</p>
<p>但是还想在item
view里显示截止日期和提醒时间，上面的就不够了。想自定义item
view的话，就得自建一个QStyledItemDelegate的子类，重新实现paint方法了。
<code>void paint(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const</code></p>
<p>感觉官方也没有给这个方法详细的解释和例子，搜到的很多也只是画了单纯的图片和文字，没有像checkbox这样的控件。</p>
<p>这个方法里最让我搞不懂的就是<code>option</code>。好像都是基于<code>option.rect</code>来画出自定义的界面。后来通过debug打印出来rect的size和position，才搞懂一些。</p>
<p><code>paint</code>方法有还有个<code>index</code>参数，而<code>option</code>也对应了这个<code>index</code>的item，每个<code>option.rect</code>的位置是对应了<code>index</code>的item在QListView里显示的位置。</p>
<p>然后就是不同类型的<code>option</code>，比如<code>paint</code>方法参数的option是<code>QStyleOptionViewItem</code>类型，对应的是item
view。而如果我要在item
view上画一个checkbox，那这个checkbox需要另建一个类型为<code>QStyleOptionButton</code>的实例，比如把这个实例命名为<code>checkBoxOpt</code>。那么<code>checkBoxOpt.rect</code>的位置应该根据<code>option.rect</code>的位置来设定。</p>
<p>下面就是我在paint方法里用来画checkbox的代码，这里还包括了通过index获得该item的<code>TaskCompleteRole</code>数据，表示这个task是否已经完成，并由此设定该item的checkbox是否被勾选。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Draw checkbox</span></span><br><span class="line">QStyleOptionButton checkBoxOpt;</span><br><span class="line">checkBoxOpt.rect = <span class="built_in">createCheckBoxRect</span>(option, checkBoxOpt);</span><br><span class="line">checkBoxOpt.state = QStyle::State_Enabled;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isChecked = index.<span class="built_in">data</span>(TaskCompleteRole).<span class="built_in">toBool</span>();</span><br><span class="line"><span class="keyword">if</span> (isChecked)</span><br><span class="line">&#123;</span><br><span class="line">    checkBoxOpt.state |= QStyle::State_On;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    checkBoxOpt.state |= QStyle::State_Off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QApplication::<span class="built_in">style</span>()-&gt;<span class="built_in">drawControl</span>(QStyle::CE_CheckBox, &amp;checkBoxOpt, painter);</span><br></pre></td></tr></table></figure>
<code>createCheckBoxRect</code>是用来确定checkbox的rect的位置，这个方法在之后改变checkbox状态的时候也用到。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">TaskViewDelegate::createCheckBoxRect</span><span class="params">(<span class="type">const</span> QStyleOptionViewItem&amp; option, <span class="type">const</span> QStyleOptionButton&amp; checkBoxOpt)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QSize checkBoxSize = QApplication::<span class="built_in">style</span>()-&gt;<span class="built_in">sizeFromContents</span>(QStyle::CT_CheckBox, &amp;checkBoxOpt, <span class="built_in">QSize</span>());</span><br><span class="line">    <span class="type">int</span> checkBoxRectTopLeftY = option.rect.<span class="built_in">topLeft</span>().<span class="built_in">y</span>() + option.rect.<span class="built_in">height</span>() / <span class="number">2</span> - checkBoxSize.<span class="built_in">height</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">checkBoxRectTopLeft</span><span class="params">(<span class="number">0</span>, checkBoxRectTopLeftY)</span></span>;</span><br><span class="line">    <span class="function">QRect <span class="title">checkBoxRect</span><span class="params">(checkBoxRectTopLeft, checkBoxSize)</span></span>;    <span class="comment">// checkBoxRect&#x27;s position should be related to the option of each item,</span></span><br><span class="line">                                                                <span class="comment">// not a fixed value, otherwise all the check box is at the same position</span></span><br><span class="line">    <span class="keyword">return</span> checkBoxRect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在可以在item
view里画出来一个checkbox了，但是怎么让checkbox被点击之后能被勾选或者取消勾选呢。参考StackOverflow的一个问答，需要重新实现<code>QStyledItemDelegate</code>的<code>editorEvent</code>方法
<code>bool editorEvent(QEvent* event, QAbstractItemModel* model, const QStyleOptionViewItem&amp; option, const QModelIndex&amp; index)</code></p>
<p>通过检测鼠标点击事件并且点击区域限定在checkbox的rect位置内，来更新该item的<code>TaskCompleteRole</code>的数据
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TaskViewDelegate::editorEvent</span><span class="params">(QEvent* event, QAbstractItemModel* model, <span class="type">const</span> QStyleOptionViewItem&amp; option, <span class="type">const</span> QModelIndex&amp; index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonRelease)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;editorEvent: option.rect.size()&quot;</span> &lt;&lt; option.rect.<span class="built_in">size</span>();</span><br><span class="line">        QMouseEvent* pME = <span class="built_in">static_cast</span>&lt;QMouseEvent*&gt;(event);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;pME-&gt;pos()&quot;</span> &lt;&lt; pME-&gt;<span class="built_in">pos</span>();</span><br><span class="line">        QStyleOptionButton checkBoxOpt;</span><br><span class="line">        QRect checkBoxRec = <span class="built_in">createCheckBoxRect</span>(option, checkBoxOpt);</span><br><span class="line">        <span class="keyword">if</span> (checkBoxRec.<span class="built_in">contains</span>(pME-&gt;<span class="built_in">pos</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> value = index.<span class="built_in">data</span>(TaskCompleteRole).<span class="built_in">toBool</span>();</span><br><span class="line">            model-&gt;<span class="built_in">setData</span>(index, !value, TaskCompleteRole);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> QStyledItemDelegate::<span class="built_in">editorEvent</span>(event, model, option, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面这两个个例子给了我很大启发。</p>
<p>自定义的item view里checkbox改变状态
https://stackoverflow.com/questions/36778577/qstyleditemdelegate-how-to-make-checkbox-button-to-change-its-state-on-click</p>
<p>在QListView里展示自定义wedget
https://stackoverflow.com/questions/53105343/is-it-possible-to-add-a-custom-widget-into-a-qlistview</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Multivariate derivative chain rule with vector or matrix, in Machine Learning</title>
    <url>/2024/06/30/Multivariate-derivative-chain-rule-with-vector-or-matrix-in-Machine-Learning/</url>
    <content><![CDATA[<p>阅前提醒： - 本文可能使用了大量比较随便的英文表达； -
本文的数学名词、公式可能不严谨； - 总之意思传达到就行。</p>
<p>While doing the lab <code>Backpropogation</code> from week 3 of <a
href="https://www.coursera.org/learn/multivariate-calculus-machine-learning?specialization=mathematics-machine-learning">Math
for ML course</a>, some questions poped up in my mind.</p>
<span id="more"></span>
<h1 id="some-background">Some background</h1>
<figure>
<img src="pic_1719776941118.png" alt="picture 0" />
<figcaption aria-hidden="true">picture 0</figcaption>
</figure>
<figure>
<img src="pic_1719776957370.png" alt="picture 1" />
<figcaption aria-hidden="true">picture 1</figcaption>
</figure>
<p><span class="math inline">\(\boldsymbol{a}^{(L)}\)</span> is the
values of the nodes at layer L. <span
class="math inline">\(\boldsymbol{a}^{(L)} = [a_0^{(L)}, a_1^{(L)},
\dots, a_{m-1}^{(L)}]\)</span>, where <code>m</code> is the number of
nodes at layer <code>L</code>.</p>
<p><span class="math inline">\(z^{(L)}\)</span> is the values before
passing to activation function, just a trick to make the derivation of
the activation function easier.</p>
<p><span class="math inline">\(\boldsymbol{W}^{(L)}\)</span> is the
weight from layer <code>L-1</code> to layer <code>L</code>, and <span
class="math inline">\(\boldsymbol{b}^{(L)}\)</span> is the bias from
layer L-1 to Layer 1.</p>
<p><span class="math inline">\(\sigma\)</span> is some activation
function.</p>
<p><span class="math inline">\(C\)</span> is the cost function, <span
class="math inline">\(y_i\)</span> is the truth value in the dataset for
training the network, corresponding to a input <span
class="math inline">\(a_i^{(0)}\)</span></p>
<p>What we want to do is to find good <span
class="math inline">\(\boldsymbol{W}^{(L)}\)</span> and <span
class="math inline">\(\boldsymbol{b}^{(L)}\)</span> that minimize the
cost, and for that we need to take partial derivative of <span
class="math inline">\(C\)</span> with respect to each W and b.</p>
<h1 id="questions">Questions</h1>
<p>In the lab <code>Backpropogation</code>, I doubted a partial
derivative formula: <span class="math display">\[
\frac{\partial C}{\partial \boldsymbol{W}^{(3)}} = \frac{\partial
C}{\partial \boldsymbol{a}^{(3)}} \frac{\partial
\boldsymbol{a}^{(3)}}{\partial \boldsymbol{z}^{(3)}} \frac{\partial
\boldsymbol{z}^{(3)}}{\partial \boldsymbol{W}^{(3)}}
\]</span></p>
<ol type="1">
<li>Why we can take partial derivative of <span
class="math inline">\(C\)</span> with respect to <span
class="math inline">\(\boldsymbol{W}\)</span>?</li>
<li>In the cost function, it sums the squre of <span
class="math inline">\(a_i^{(L)} - y_i\)</span>, why in the derivative
formula it becomes the partial derivative of <span
class="math inline">\(C\)</span> with respect to <span
class="math inline">\(\boldsymbol{a}\)</span>, and how?</li>
</ol>
<h1 id="analysis">Analysis</h1>
<p>In the previous lectures, I've learned about chain rule for
multivariate derivative with function being like this form: <span
class="math display">\[
f(\boldsymbol{x}(t)), \boldsymbol{x} = [x_1(t), x_2(t), ... x_n(t)]
\]</span></p>
<p><span class="math inline">\(f\)</span> is a function of <span
class="math inline">\(x_1(t), x_2(t), ... x_n(t)\)</span>, and each
elements of <span class="math inline">\(\boldsymbol{x}\)</span> is a
function of <span class="math inline">\(t\)</span>, and in the end,
<span class="math inline">\(f\)</span> can be a function of <span
class="math inline">\(t\)</span>. Thus, we can try to find derivative of
<span class="math inline">\(f\)</span> with respect to <span
class="math inline">\(t\)</span>, by using multivariate chain rule:</p>
<p><strong>Equation 1</strong> <span class="math display">\[
\frac{df}{dt} = \frac{\partial f}{\partial \boldsymbol{x}}
\frac{d\boldsymbol{x}}{dt}
\]</span></p>
<p><strong>Equation 2</strong> <span class="math display">\[
\frac{df}{dt} = \frac{\partial f}{\partial x_1} \frac{dx_1}{dt} +
\frac{\partial f}{\partial x_2} \frac{dx_2}{dt} + \dots + \frac{\partial
f}{\partial x_n} \frac{dx_n}{dt}
\]</span></p>
<p>The <span class="math inline">\(\frac{\partial f}{\partial
\boldsymbol{x}}\)</span> and <span
class="math inline">\(\frac{d\boldsymbol{x}}{dt}\)</span> in Equation 1
are vectors, and <span class="math inline">\(\frac{df}{dt}\)</span> is
the <strong>dot product</strong> of these two vectors. The result of dot
product just equals to the sum Equation 2. Therefore, we can use the
simple form Equation 1.</p>
<p>The independent variable <span class="math inline">\(t\)</span> is a
single variable. However, what would the formula be if <span
class="math inline">\(t\)</span> is also a pack of variables? e.g.:
<span class="math display">\[
\boldsymbol{t} = [t_1, t_2]
\]</span></p>
<p>To make it easier for understanding, we can use an example, say <span
class="math inline">\(\boldsymbol{x} = [x_1, x_2]\)</span>, and <span
class="math inline">\(\boldsymbol{t} = [t_1, t_2]\)</span>, <span
class="math inline">\(f\)</span> is a function of <span
class="math inline">\(\boldsymbol{x}\)</span>, <span
class="math inline">\(f(\boldsymbol{x})\)</span>, (or explicitly <span
class="math inline">\(f(x_1, x_2)\)</span>, and each element in <span
class="math inline">\(\boldsymbol{x}\)</span> is a function of <span
class="math inline">\(\boldsymbol{t}\)</span>: <span
class="math display">\[
x = [x_1(\boldsymbol{t}), x_2(\boldsymbol{t})]
\]</span></p>
<p>or explicitly <span class="math display">\[
x = [x_1(t_1, t_2), x_2(t_1, t_2)]
\]</span></p>
<p>So, <span class="math inline">\(f\)</span> can be a function of <span
class="math inline">\(t_1\)</span> and <span
class="math inline">\(t_2\)</span>. Now, if we want to find derivative
of <span class="math inline">\(f\)</span> with respect to <span
class="math inline">\(\boldsymbol{t}\)</span>, we have to do partial
defferentiation on <span class="math inline">\(t_1\)</span> and <span
class="math inline">\(t_2\)</span> respectively: <span
class="math display">\[
\frac{\partial f}{\partial t_1} = \frac{\partial f}{\partial
x_1}\frac{\partial x_1}{\partial t_1} + \frac{\partial f}{\partial
x_2}\frac{\partial x_2}{\partial t_1}
\]</span></p>
<p>It can be written as dot product of vector <span
class="math display">\[
\frac{\partial f}{\partial \boldsymbol{x}} = [\frac{\partial f}{\partial
x_1}, \frac{\partial f}{\partial x_2}]
\]</span></p>
<p>and vector <span class="math display">\[
\frac{\partial \boldsymbol{x}}{\partial t_1} = [\frac{\partial
x_1}{\partial t_1}, \frac{\partial x_2}{\partial t_1}]
\]</span></p>
<p>Thus, <span class="math display">\[
\frac{\partial f}{\partial t_1} = \frac{\partial f}{\partial
\boldsymbol{x}}\frac{\partial \boldsymbol{x}}{\partial t_1}
\]</span></p>
<p>And similarly for <span class="math inline">\(t_2\)</span> <span
class="math display">\[
\frac{\partial f}{\partial t_2} = \frac{\partial f}{\partial
\boldsymbol{x}}\frac{\partial \boldsymbol{x}}{\partial t_2}
\]</span> Until here, we can roughly answer a part of the question
1:</p>
<p><span class="math inline">\(C\)</span> is a function of <span
class="math inline">\(\boldsymbol{a}^{(L)}\)</span>, and <span
class="math inline">\(\boldsymbol{a}^{(L)}\)</span> is a function of
<span class="math inline">\(\boldsymbol{W}^{(L)}\)</span> and <span
class="math inline">\(\boldsymbol{b}^{(L)}\)</span>. Therefore, <span
class="math inline">\(C\)</span> can also be a function of <span
class="math inline">\(\boldsymbol{W}^{(L)}\)</span> and <span
class="math inline">\(\boldsymbol{b}^{(L)}\)</span>.</p>
<p>Just like above example(<span class="math inline">\(f\)</span>, <span
class="math inline">\(t_1\)</span>, and <span
class="math inline">\(t_2\)</span>), we can take partial derivative of
<span class="math inline">\(C\)</span> with respective <span
class="math inline">\(\boldsymbol{W}^{(L)}\)</span> and <span
class="math inline">\(\boldsymbol{b}^{(L)}\)</span>.</p>
<p>However, there is new question:</p>
<p><span class="math inline">\(\boldsymbol{W}^{(L)}\)</span> is a
matrix, how do we take derivative with respect to a matrix?</p>
<h2
id="key-point-derivative-with-respect-to-each-element-in-matrixvector">Key
point: derivative with respect to each element in matrix/vector</h2>
<p>My idea is that, this is just a simpler form for writing. We can't
take derivative with respect to a matrix or vector, but we actually do
that on <strong>each element</strong> in the matrix or vector.</p>
<p>For the above example <span class="math inline">\(f\)</span>, <span
class="math inline">\(t_1\)</span>, and <span
class="math inline">\(t_2\)</span>, we can also put <span
class="math inline">\(\frac{\partial f}{\partial t_1}\)</span> and <span
class="math inline">\(\frac{\partial f}{\partial t_2}\)</span> together
in a vector, and write: <span class="math display">\[
\frac{\partial f}{\partial \boldsymbol{t}} = [\frac{\partial f}{\partial
t_1}, \frac{\partial f}{\partial t_2}]
\]</span></p>
<h1 id="answer-to-the-question">Answer to the question</h1>
<p><span class="math inline">\(C\)</span> is a function of <span
class="math inline">\(\boldsymbol{a}^{(L)} = [a_0^{(L)}, a_1^{(L)},
\dots, a_{m-1}^{(L)}]\)</span>.</p>
<p>Each <span class="math inline">\(a_i^{(L)}\)</span> is a function of
<span class="math inline">\(\boldsymbol{w}_i^{(L)} = [w_{i,0}^{(L)},
w_{i,1}^{(L)}, \dots, w_{i,n-1}^{(L)}]\)</span> and <span
class="math inline">\(b_i^{(L)}\)</span>. <code>n</code> is the number
of nodes in the layer <code>L-1</code>.</p>
<p>We, in fact, are not taking derivative of <span
class="math inline">\(C\)</span> with respect to the matrix <span
class="math inline">\(\boldsymbol{W}^{(L)}\)</span>, but to each
variable <span class="math inline">\(w_{i,j}^{(L)}\)</span>, while in
the end, writing the result as simpler form <span
class="math inline">\(\frac{\partial C}{\partial
\boldsymbol{W}^{(L)}}\)</span>.</p>
<p>Same for <span class="math inline">\(\frac{\partial C}{\partial
\boldsymbol{a}^{(L)}}\)</span>, we need to take derivative of <span
class="math inline">\(C\)</span> with respect to each variable <span
class="math inline">\(a_i^{(L)}\)</span>, and in the end write as a
simpler form.</p>
<p>So let's start by doing derivative of <span
class="math inline">\(z_i^{(L)}\)</span> with respect to <span
class="math inline">\(\boldsymbol{w}_i^{(L)}\)</span>.</p>
<p>Expan the formula <span class="math inline">\(z_i^{(L)} =
\boldsymbol{w}_i^{(L)} \cdot \boldsymbol{a}^{(L-1)} +
b_i^{(L)}\)</span>: <span class="math display">\[
z_i^{(L)} = [w_{i,0}^{(L)}, w_{i,1}^{(L)}, \dots, w_{i,n-1}^{(L)}] \cdot
[a_0^{(L-1)}, a_1^{(L-1)}, \dots, a_{n-1}^{(L-1)}] + b_i^{(L)}
\]</span></p>
<p>We can easily get the result of taking derivative of <span
class="math inline">\(z_i\)</span> with respect to <span
class="math inline">\(w_{i,j}^{(L)}\)</span>, it's just <span
class="math inline">\(a_j^{(L-1)}\)</span>. But let's keep these
derivative symbols (since the result is not important for our topic) and
put all the derivatives in a vector:</p>
<p><strong>Equation 3</strong> <span class="math display">\[
\frac{\partial z_i^{(L)}}{\partial \boldsymbol{w}_i^{(L)}} =
[\frac{\partial z_i^{(L)}}{\partial w_{i, 0}^{(L)}}, \frac{\partial
z_i^{(L)}}{\partial w_{i, 1}^{(L)}}, \cdots, \frac{\partial
z_i^{(L)}}{\partial w_{i, n-1}^{(L)}}]
\]</span></p>
<p>And then we take derivative of <span
class="math inline">\(a_i^{(L)}\)</span> with respect to <span
class="math inline">\(z_i^{(L)}\)</span>: <span class="math display">\[
\frac{\partial a_i^{(L)}}{\partial z_i^{(L)}} =
\sigma^{\prime}(z_i^{(L)})
\]</span></p>
<p>Then we do <span class="math inline">\(\frac{\partial C}{\partial
a_i^{(L)}}\)</span>. Remember that: <span class="math display">\[
C = \sum_i (a_i^{(L)} - y_i)^2 = (a_0^{(L)} - y_0)^2 + (a_1^{(L)} -
y_1)^2 + \cdots + (a_{m-1}^{(L)} - y_{m-1})^2
\]</span></p>
<p>We only take derivative with respect to <span
class="math inline">\(a_i^{(L)}\)</span>: <span class="math display">\[
\frac{\partial C}{\partial a_i^{(L)}} = 2(a_i^{(L)} - y_i)
\]</span></p>
<p>At last, we can get partial derivative of <span
class="math inline">\(C\)</span> respect to each <span
class="math inline">\(w_{i,j}^{(L)}\)</span> <span
class="math display">\[
\frac{\partial C}{\partial w_{i,j}^{(L)}} = \frac{\partial C}{\partial
a_i^{(L)}}\frac{\partial a_i^{(L)}}{\partial z_i^{(L)}}\frac{\partial
z_i^{(L)}}{\partial w_{i,j}^{(L)}}
\]</span></p>
<p>All the derivative term <span class="math inline">\(\frac{\partial
C}{\partial a_i^{(L)}}\)</span>, <span
class="math inline">\(\frac{\partial a_i^{(L)}}{\partial
z_i^{(L)}}\)</span>, <span class="math inline">\(\frac{\partial
z_i^{(L)}}{\partial w_{i,j}^{(L)}}\)</span>, are just scalars, so is the
result <span class="math inline">\(\frac{\partial C}{\partial
w_{i,j}^{(L)}}\)</span>.</p>
<p>Now, what if we replace the single variable <span
class="math inline">\(w_{i,j}^{(L)}\)</span> with a vector <span
class="math inline">\(\boldsymbol{w}_i^{(L)}\)</span>?</p>
<p>Then the last term becomes the <strong>Equation 3</strong>. It is a
vector! The first and second term doesn't change, because we still take
derivative with respect to <span
class="math inline">\(a_i^{(L)}\)</span> and <span
class="math inline">\(z_i^{(L)}\)</span>.</p>
<p>So what happens to <span class="math inline">\(\frac{\partial
C}{\partial w_{i,j}^{(L)}}\)</span>? It also turns to a vector! <span
class="math display">\[
\frac{\partial C}{\partial \boldsymbol{w}_i^{(L)}} = [ \frac{\partial
C}{\partial w_{i,0}^{(L)}}, \frac{\partial C}{\partial w_{i,1}^{(L)}},
\cdots, \frac{\partial C}{\partial w_{i, n-1}^{(L)}} ]
\]</span></p>
<p>What is <span class="math inline">\(\boldsymbol{w}_i^{(L)}\)</span>?
It is the <code>i</code>th row of the matrix <span
class="math inline">\(\boldsymbol{W}^{(L)}\)</span>. If we then do
similar things to each row of <span
class="math inline">\(\boldsymbol{W}^{(L)}\)</span>, and stack them
together, we get a new matrix, that is <span
class="math inline">\(\frac{\partial C}{\partial
\boldsymbol{W}^{(L)}}\)</span>! <span class="math display">\[
\frac{\partial C}{\partial \boldsymbol{W}^{(L)}} =
\begin{bmatrix}
   \frac{\partial C}{\partial \boldsymbol{w}_0^{(L)}}  \\
   \frac{\partial C}{\partial \boldsymbol{w}_1^{(L)}}  \\
   \vdots \\
   \frac{\partial C}{\partial \boldsymbol{w}_{m-1}^{(L)}}
\end{bmatrix}
\]</span></p>
<h1 id="take-away">Take away</h1>
<p>When there is vector or matrix in a derivative formula, we are taking
derivative with respect to each element in matrix or vector.</p>
]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>对编程中的取模运算的一些发现</title>
    <url>/2024/07/01/%E5%AF%B9%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<p>看c++ primer的时候看到赋值溢出会取模，-1赋给unsigned
char得到255（第五版中文p33），让我对负数取模的运算产生了疑问。</p>
<span id="more"></span>
<h1 id="问题">问题</h1>
<p>于是又翻了下英文书(p35)，意思是一样的：</p>
<blockquote>
<p>If we assign an out-of-range value to an object of unsigned type, the
result is the remainder of the value modulo the number of values the
target type can hold. For example, an 8-bit unsigned char can hold
values from 0 through 255, inclusive. If we assign a value outside this
range, the compiler assigns the remainder of that value modulo 256.
Therefore, <strong>assigning –1 to an 8-bit unsigned char gives that
object the value 255</strong>.</p>
</blockquote>
<p>马上用C++试了下，<code>-1 % 256</code>，结果是<code>-1</code>。是C++有问题还是我理解有问题？正准备手算一下，突然了新问题，负数的取模运算该怎么算？</p>
<h1 id="解答">解答</h1>
<p>上一次正经学相关内容大概要追溯到本科学离散数学的时候了，已经记不得什么了，不如搜一下。也是发现<a
href="https://stackoverflow.com/questions/11630321/why-does-c-output-negative-numbers-when-using-modulo">stackoverflow上有类似的疑问</a>，而且有了新发现，那就是Python的取模运算结果和C++不一样。</p>
<p>维基百科里给出了不同语言在<a
href="https://en.wikipedia.org/wiki/Modulo#In_programming_languages">取模运算上不同的定义</a>。</p>
<p>根据百科对<strong>模</strong>的定义，“modulo operation returns the
remainder or signed remainder of a
division”，实际上取余取模其实是一回事。并且运算使用的是<strong>欧几里得除法</strong>：</p>
<p>a和b是整数，存在唯一的q和r，满足： <span class="math display">\[
\begin{matrix}
a = bq+r \\
0 \leq r \lt |b| \\
b \neq 0
\end{matrix}
\]</span></p>
<p>从定义里就能看出，余数是非负的。但是在编程语言里，并不一定满足<span
class="math inline">\(r \geq 0\)</span>，当<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>有一个是负数的情况下，不同编程语言就有不同的处理。而且在某个版本的C++之前，余数的符号还是由C++的实现决定的（也就是说用不同的编译器可能会有不同的结果）。</p>
<p>目前C++的取模运算使用truncated定义，也就是商舍去小数部分，向0取整。例如-0.5变成0，-1.5会变成-1,
1.5变成1，0.5变成0。</p>
<p>这也就解释了为什么<code>-1\%256 = -1</code>。首先<code>-1/256</code>商是<code>0</code>，然后<code>r = a-bq = -1 - 256*0 = -1</code>。</p>
<p>而Python使用的是Floored定义，商向下取整。例如-1.5变成-2，-0.5变成-1，1.5变成1，0.5变成0。
在这种情况下<span class="math inline">\(q = \lfloor -1/256
\rfloor  =  -1\)</span>，那么<span class="math inline">\(r = -1 - 256 *
(-1) = 255\)</span>。</p>
<h1 id="其他">其他</h1>
<h2 id="c的定义">C++的定义</h2>
<p>我还查了下<a
href="https://en.cppreference.com/w/cpp/language/operator_arithmetic">cppreference</a>，对%(remainder
operator)的定义是(只节选了相关部分）：</p>
<blockquote>
<p><code>lhs % rhs</code></p>
</blockquote>
<blockquote>
<p>The result of built-in remainder is the remainder of the integer
division of lhs by rhs. If rhs is zero, the behavior is undefined.</p>
</blockquote>
<blockquote>
<p>If a / b is representable in the result type, (a / b) * b + a % b ==
a.</p>
</blockquote>
<blockquote>
<p>Note: Until CWG issue 614 was resolved (N2757), if one or both
operands to binary operator % were negative, the sign of the remainder
was implementation-defined, as it depends on the rounding direction of
integer division. The function std::div provided well-defined behavior
in that case.</p>
</blockquote>
<p>而 integer division：</p>
<blockquote>
<p><code>lhs / rhs</code></p>
</blockquote>
<blockquote>
<p>The result of built-in division is lhs divided by rhs. If rhs is
zero, the behavior is undefined.</p>
</blockquote>
<blockquote>
<p>If both operands have an integral type, the result is the algebraic
quotient (performs integer division): the quotient is truncated towards
zero (fractional part is discarded).</p>
</blockquote>
<p>商向0取整，与维基百科的内容相符。它也是说了在CWG issue
614被解决之前C++的余数符号是由实现决定的，不过现在已经统一了。</p>
<h2 id="编程中取模的陷阱">编程中取模的陷阱</h2>
<p>维基百科里的例子就很好，判断一个整数是否是奇数可能会写这样的代码
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(a%2 == 1)</span><br></pre></td></tr></table></figure> 那么如果a是负数，python会得到1，但是c++会得到-1。</p>
<p>在忽视了负数除数或者被除数可能是负数的情况下，如果不了解取模运算在编程中会有不同定义的话，就会出错了。</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>C++</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>unnamed namespace and using declaration</title>
    <url>/2024/07/08/unnamed-namespace-and-using-declaration/</url>
    <content><![CDATA[<p>在工作中经常看到这样的代码。好奇为什么要用<code>unnamed namespace</code>，以及在<code>unnamed namespace</code>里用<code>using</code>会有什么效果。
<span id="more"></span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NS_A1 &#123;</span><br><span class="line">	<span class="keyword">namespace</span> NS_A2 &#123;</span><br><span class="line">		<span class="keyword">namespace</span> NS_A3 &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">namespace</span> &#123;</span><br><span class="line">				<span class="keyword">using</span> NS_B1::NS_B2::NS_B3::ClassB;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// some local variables</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">				<span class="comment">// ... use ClassB methods</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="unnamed-namespace-scope">unnamed namespace scope</h1>
<h2 id="unnamed-namespace不同于常规的namespace之处">unnamed
namespace不同于常规的namespace之处</h2>
<p>首先想搞明白的就是<code>unnamed namespace</code>的scope（作用域）。</p>
<p><code>unnamed namespace</code>只作用在当前的文件，也就是说如果两个cpp文件里都有<code>unnamed namespace</code>，那么他们没有任何关联。</p>
<p>如果<code>unnamed namespace</code>是定义在头文件里，那么引用头文件的cpp文件用到的<code>unnamed namespace</code>里的成员也是仅属于当前的cpp文件。也就是说，比如有两个cpp文件都用到头文件<code>unnamed namespace</code>的某个变量<code>a</code>，那么相当于他们都创建了只能在自己cpp文件使用的<code>a</code>变量，各种操作当然只会对自己的<code>a</code>起作用。</p>
<p>示例： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nsInHeader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;in main, before change, a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;in main, after change, a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nsInHeader.h</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nsInHeader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;in func, a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>运行输出结果：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">in main, before change, a: 0</span><br><span class="line">in func, a: 0</span><br><span class="line">in main, after change, a: 1</span><br><span class="line">in func, a: 0</span><br></pre></td></tr></table></figure>
<h2 id="定义在unnamed-namespace里的成员的scope">定义在unnamed
namespace里的成员的scope</h2>
<p>定义在<code>unnamed namespace</code>里的成员跟这个<code>unnamed namespace</code>本身的scope相同。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ primer例子，英文第五版p791</span></span><br><span class="line"><span class="type">int</span> i;   <span class="comment">// global declaration for i</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ambiguous: defined globally and in an unnested, unnamed namespace</span></span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
如果<code>unnamed namespace</code>定义在一个文件的最外层scope，相当于定义在这个文件的global
scope，那<code>unnamed namespace</code>的成员也相当于定义在global
scope。</p>
<p>这也是为什么<code>unnamed namespace</code>能够取代static变量。定义在global
scope的<code>unnamed namespace</code>里的成员跟用static声明的变量都只在当前文件里可用，对其他文件不可见。</p>
<h2
id="通过例子看普通namespace和unnamed-namespace的区别">通过例子看普通namespace和unnamed
namespace的区别</h2>
<p>分别在两个cpp文件里定义namespace NS1，并在namespace里定义一个变量：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ns1.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> NS1 &#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="comment">// reopen the namespace NS1:</span></span><br><span class="line"><span class="keyword">namespace</span> NS1 &#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这时候编译不会有问题，但是link的时候会报错： "multiple
definition of NS1::a;".</p>
<p>但是如果改成下面这样： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ns1.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> NS1 &#123;</span><br><span class="line">	<span class="keyword">namespace</span>&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="comment">// reopen the namespace NS1:</span></span><br><span class="line"><span class="keyword">namespace</span> NS1 &#123;</span><br><span class="line">	<span class="keyword">namespace</span>&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 就不会报错了。</p>
<p>这是因为普通的namespace可以展开到多个文件，但是就如之前所说，unnamed
namespace只在当前的文件有效。</p>
<h1 id="using">Using</h1>
<p>把别的namespace的成员引入当前的namespace，有两种using的用法：using
declaration和using Directives。 这里用到的是using
declaration所以就只讨论它。关于using
directive，我发现了一篇很好的文章，放在后面了。</p>
<h2 id="using-declaration">using declaration</h2>
<blockquote>
<p><strong>In namespace and block scope</strong></p>
<p>Using-declarations introduce a member of another namespace into the
current namespace or block scope.</p>
<p>https://en.cppreference.com/w/cpp/language/using_declaration</p>
</blockquote>
<p>之前提到的<code>using NS_B1::NS_B2::NS_B3::ClassB;</code>就属于<code>using declaration</code>。它只是把其它namespace的成员引入到当前的scope。</p>
<p>而“定义在<code>unnamed namespace</code>里的成员跟这个<code>unnamed namespace</code>本身的scope相同”。</p>
<p>也就是说，其实<code>using declaration</code>放不放在<code>unnamed namespace</code>里，效果都是一样的。</p>
<p>那么我猜在工作中看到<code>using declaration</code>放在<code>unnamed namespace</code>只是顺便；因为<code>unnamed namespace</code>里还定义了别的变量和函数，这些成员只在当前文件可见；别的文件如果用了相同的<code>enclosing namespace</code>的，也定义了类似的变量和函数，放在<code>unnamed namespace</code>里就不会导致命名冲突。</p>
<h3 id="include">include</h3>
<blockquote>
<p>#include &lt; h-char-sequence &gt; new-line (1)</p>
<p>#include " q-char-sequence " new-line (2)</p>
<ol type="1">
<li><p>Searches for a header identified uniquely by h-char-sequence and
replaces the directive by the entire contents of the header.</p></li>
<li><p>Searches for a source file identified by q-char-sequence and
replaces the directive by the entire contents of the source file. It may
fallback to (1) and treat q-char-sequence as a header
identifier.</p></li>
</ol>
<p>https://en.cppreference.com/w/cpp/preprocessor/include</p>
</blockquote>
<p>在preprocessor处理cpp文件的时候，include
directive会把头文件的全部内容拿过来。</p>
<h3 id="translation-unit">Translation Unit</h3>
<p>一个translation unit就是一个cpp文件和它引用的头文件。
https://stackoverflow.com/questions/1106149/what-is-a-translation-unit-in-c</p>
<p>所以，如果不把<code>using declaration</code>放在头文件里并被另一个cpp文件引用的话，这个<code>using declaration</code>对于另一个cpp文件来说就是不可见的。</p>
<h2 id="using-directives">using Directives</h2>
<p>https://quuxplusone.github.io/blog/2020/12/21/using-directive/</p>
<p>这篇文章说用using directive会把target namespace的成员引入到target
namespace和current scope的least common ancestor的scope里。</p>
<p>而且这个引入的效果仅限在current
scope（以及它包含的scope）里。在外层和其他的的scope里，target
namespace的成员依然是不可见的。</p>
<p>而且最后的建议就是不要用using Directives。</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>steam deck 换固态重装系统</title>
    <url>/2024/01/09/steam-deck-%E6%8D%A2%E5%9B%BA%E6%80%81%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>得用好点的U盘而且是USB3以上，不然安装的时候容易卡在进入桌面之前的过程。</p>
<p>手边没有合适的U盘，最后只能在sd卡里刷入镜像来重装steamos到ssd里。</p>
<p>安装的时候选Re-image Steam
Deck。看了几个教程要么没提到要么是用的Reinstall Steam
OS，但是因为换了固态硬盘什么都没有了所以选Re-image Steam
Deck才能继续安装，Reinstall Steam OS运行之后没有什么反应。</p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
  </entry>
  <entry>
    <title>Joplin笔记软件推荐和设置</title>
    <url>/2024/01/07/Joplin%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%92%8C%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>Joplin用了也有大半年了，真是相见恨晚，几乎满足了我对笔记软件的所有需求（硬要说的话可能就是不能手写笔记）：本地一定有一份备份，能在多端查看，文件格式最好是开放的，并且方便导入导出。</p>
<span id="more"></span>
<p>最早的时候是用有道云笔记，也用过onenote，后来换成了vscode+markdown，再后来终于找到了Joplin。</p>
<p>Joplin的优点：</p>
<ul>
<li>使用markdown格式，而且粘贴图片也很方便，还能添加附件</li>
<li>支持多端：Windows, Linux, macOS, Android and iOS</li>
<li>可完全本地离线运行，不需要账号</li>
<li>也可以自己设置同步服务，支持WebDav，S3，OneDrive等，它自己也提供云服务</li>
<li>非常方便地导入导出
<ul>
<li>支持导入html、markdown、txt和evernote</li>
<li>支持导出markdown、pdf、html</li>
</ul></li>
<li>免费，开源</li>
</ul>
<blockquote>
<p>https://joplinapp.org/</p>
</blockquote>
<blockquote>
<p>https://github.com/laurent22/joplin</p>
</blockquote>
<h1 id="修改本地存储位置">修改本地存储位置</h1>
<p>Joplin默认把数据放在<code>C:\Users\&lt;username&gt;\.config\joplin-desktop</code>，但是官方竟然没有更改存储位置的设置项。</p>
<p>不过有一个非官方的方法，在windows上，在Joplin的桌面快捷方式右键-&gt;属性-&gt;快捷方式-&gt;<code>目标</code>，结尾加上<code>--profile "新的路径"</code>，注意<code>--</code>之前和<code>profile</code>之后都有空格。</p>
<blockquote>
<p>https://www.cnblogs.com/KoiC/p/16541109.html</p>
</blockquote>
<p>虽然不是offical
support的，之后也不知道会不会更新改本地存储位置的功能，目前也只能暂时用这个方法了。</p>
<h1 id="云同步">云同步</h1>
<p>使用阿里云OSS云同步 https://www.jianshu.com/p/f2ced7e002ff</p>
<p>使用腾讯云COS云同步 https://zhuanlan.zhihu.com/p/346460176</p>
<p>我自己用的是阿里云的，看着计费挺复杂的，但是可能我用量很小，到现在还没有被计费过。虽然我选的是国内的节点（看起来便宜些），但是在欧洲用同步功能也没碰到过非常慢的情况。</p>
<h1 id="插件">插件</h1>
<p>下面几个是我自己使用的插件：</p>
<h2 id="outline">Outline</h2>
<p>https://joplinapp.org/plugins/plugin/outline/</p>
<p>用vscode写markdown的话，左边会显示以标题为列表的outline，但是Joplin默认没有这个功能。这个插件增加了一个显示标题大纲的组件。</p>
<p>我发现新增的插件组件，好像默认会显示在Joplin窗口的最右边。不过Joplin支持自定义布局，可以自己拖动插件组件的位置，我把它放到了笔记列表同一列，就跟vscode布局一样了。</p>
<h2 id="note-tabs">Note Tabs</h2>
<p>https://joplinapp.org/plugins/plugin/joplin.plugin.note.tabs/</p>
<p>Joplin默认也没有tabs，也就是没法像vscode那样同时打开多个文档。这个插件让Joplin也支持tabs（同样需要自己调整布局，默认在Joplin窗口的最右边）。</p>
<h2 id="rich-markdown">Rich Markdown</h2>
<p>https://joplinapp.org/plugins/plugin/plugin.calebjohn.rich-markdown</p>
<p>Joplin默认的编辑器样式是左边纯文本markdown，右边渲染预览。能不能像Typora那样渲染和编辑在一起呢？这个插件就实现了这个功能，节省显示空间。</p>
<h2 id="table-formatter-plugin">Table Formatter Plugin</h2>
<p>https://joplinapp.org/plugins/plugin/net.rmusin.joplin-table-formatter</p>
<p>方便排版markdown表格</p>
<h2 id="search-replace">Search &amp; Replace</h2>
<p>https://joplinapp.org/plugins/plugin/joplin-plugin-search-and-replace/</p>
<p>Joplin的编辑器搜索功能（Ctrl+F）只能搜索，不能替换。这个插件就是增加搜索替换功能。</p>
<h1 id="遇到过的问题">遇到过的问题</h1>
<ol type="1">
<li>WebDav不支持坚果云
<ul>
<li>一开始是想用坚果云同步的，但是会报错，而且没找到解决方法。</li>
</ul></li>
<li>复制到新电脑上出现同步错误
<ul>
<li>把joplin的目录复制到另一台电脑上之后，在新电脑上打开joplin，提示需要重新输入笔记加密密码，和S3密钥（使用S3同步的情况下）。
尽管输入了正确的S3密钥，并且在点击“检查同步配置”的按钮之后提示没有问题，但是在同步的时候还是出现了SignatureDoesNotMatch的问题。
解决方法：重新启动Joplin</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>software</category>
      </categories>
  </entry>
  <entry>
    <title>C++ primer ch2 - Variables and Basic Types 阅读笔记</title>
    <url>/2024/07/18/C-primer-ch2-Variables-and-Basic-Types-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>最近看了下C++
roadmap，发现自己有些基础的内容还不是很懂，于是选了本经典的C++书来读，发现确实有很多基础知识没掌握。读完了第二章，边读边记了些之前不太懂和感觉重要的内容。</p>
<span id="more"></span>
<h1 id="primitive-built-in-types">Primitive Built-in Types</h1>
<p>Primitive types (fundamental types)</p>
<ul>
<li>arithmetic types</li>
<li>void</li>
</ul>
<blockquote>
<p>https://en.cppreference.com/w/cpp/language/type</p>
</blockquote>
<p>按照cppreference的说法，type就分fundamental和compound两大类，C++
primer这里说的Primitive types应该就是fundamental type的一部分。</p>
<h2 id="arithmetic-types">Arithmetic Types</h2>
<ul>
<li>integral types</li>
<li>floating-point types</li>
</ul>
<p><code>unsigned int</code>可以被简写成<code>unsigned</code>。</p>
<blockquote>
<p>The type unsigned int may be abbreviated as unsigned</p>
</blockquote>
<h2 id="type-conversions">Type Conversions</h2>
<p>out-of-range assignment</p>
<blockquote>
<p>If we assign an out-of-range value to an object of unsigned type, the
result is the remainder of the value modulo the number of values the
target type can hold.</p>
</blockquote>
<p>关于modulo怎么算，看之前的一篇文章。</p>
<blockquote>
<p>If we assign an out-of-range value to an object of signed type, the
result is <strong>undefined</strong>.</p>
</blockquote>
<h2 id="literal">literal</h2>
<p>整数literal默认类型（比我想的复杂）:</p>
<ul>
<li>decimal literals are signed
<ul>
<li>decimal literal has the smallest type of int, long, or long long
(i.e., the first type in this list) in which the literal’s value
fits</li>
</ul></li>
<li>octal and hexadecimal literals can be either signed or unsigned
types
<ul>
<li>Octal and hexadecimal literals have the smallest type of int,
unsigned int, long, unsigned long, long long, or unsigned long long in
which the literal’s value fits</li>
</ul></li>
</ul>
<h3 id="负数literal">负数literal</h3>
<p>负数literal（字面值）的符号不包含在literal里： -42
符号是一个operator，作用在42上</p>
<h3 id="floating-point-literal">Floating-point literal</h3>
<p>浮点数literal默认的类型是<strong>double</strong></p>
<h3 id="字符串literal">字符串literal</h3>
<p>字符串literal的type是<strong>常量字符数组</strong> （array of
constant chars）</p>
<h4 id="字符串连接">字符串连接</h4>
<p>两个字符串literal，中间用 空格、tab、换行
隔开的话，会被连接成单个字符串literal "a really, really long string
literal " "that spans two lines" 效果等于 "a really, really long string
literal that spans two lines"</p>
<h1 id="variables">Variables</h1>
<p>C++ Primer 对于 object 的定义是： &gt; An object is a region of
memory that has a type. We will freely use the term object regardless of
whether the object has built-in or class type, is named or unnamed, or
can be read or written.</p>
<h2 id="initializer初始值">Initializer（初始值）</h2>
<blockquote>
<p>initialization and assignment are different operations in C++</p>
</blockquote>
<p>C++里变量初始化和赋值是<strong>不同的操作</strong></p>
<blockquote>
<p>Initialization is not assignment. Initialization happens when a
variable is given a value when it is created. Assignment obliterates an
object’s current value and replaces that value with a new one.</p>
</blockquote>
<p>初始化发生在创建一个变量的时候给这个变量初始值；赋值（assignment）是更改一个对象的值，用新值替换掉旧值。</p>
<p>定义变量但是不给初始值，那么会被<code>default initialized</code>。
有built-in
type的变量，在<strong>函数之外</strong>被定义的时候如果没有给初始值，会被初始化为0。如果在<strong>函数之内</strong>被定义并没有给初始值，那么它是<strong>uninitialized</strong>，它的值是<strong>undefined</strong>。</p>
<p>自定义类型（类）的变量定义时如果没有给初始值，那初始化是由这个类来控制的。（我猜，定义这种变量不给初始值的前提，是这个类有不带参数的构造函数（constructor））。</p>
<p>建议：定义变量时就显式地给初始值。</p>
<h3 id="list-initialization">List Initialization</h3>
<p>C++11新增了<code>List Initialization</code>，用花括号初始化。也就有了下面四种初始化方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ primer EN p43</span></span><br><span class="line"><span class="type">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> units_sold&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="variable-declarations-vs-definitions">Variable Declarations vs
Definitions</h2>
<p>Declaration：makes a name known to the program, also specifying the
type</p>
<p>Definition: in addition to declaration, creates an entity associated
with a name - allocates storage and may provide the variable with an
initial value</p>
<p>definition（定义）不仅declare（声明）一个变量的名字和类型，还给这个变量分配内存，<strong>可能</strong>会给它一个初始值</p>
<p>变量可以被declare多次，可以在多个文件里被declare，但是只能被define一次，也当然只可能在一个文件里被define。</p>
<h3 id="extern">extern</h3>
<p>通过<code>extern</code>关键字只declare而不define <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">// declares but does not define i</span></span><br><span class="line"><span class="type">int</span> j; <span class="comment">// declares and defines j</span></span><br></pre></td></tr></table></figure></p>
<p>只能define一次，但是可以declare多次。下面这个例子在defa.cpp和main.cpp都define了a，会导致link
error。</p>
<p><code>#include "a.h"</code>
会把a.h里的内容替换到当前位置，所以在哪#include "a.h"就相当于在哪declare
a，在例子里也就是在defa.cpp和main.cpp都declare了a。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: a.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file: defa.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;	<span class="comment">// link error!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果把main.cpp中的定义a删去就没有问题了。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果： <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">a: 1</span><br></pre></td></tr></table></figure></p>
<p>用extern同时有初始值 = definition <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.1416</span>; <span class="comment">// definition</span></span><br></pre></td></tr></table></figure></p>
<p>但是，在函数里用extern声明变量并给初始值的话就是<strong>错误</strong>。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.1416</span>;	<span class="comment">// compile error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="conventions-for-variable-names">Conventions for Variable
Names</h2>
<p>原来C++里面有一类名字是<code>C++ Alternative Operator Names</code>，可以像python一样用and，or，not等等表示布尔运算。这些alternative
operator是给一些没有&amp;、|这种符号的编码集用的。（很少见，之前根本不知道）</p>
<h1 id="compound-types">Compound Types</h1>
<p>declaration更广泛的定义： &gt; More generally, a declaration is a
<strong>base type</strong> followed by a list of
<strong>declarators</strong>. Each declarator names a variable and gives
the variable a type that is related to the base type.</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i3 = <span class="number">1024</span>, &amp;ri = i3; <span class="comment">// i3 is an int; ri is a reference bound to i3</span></span><br><span class="line"><span class="comment">// int是base type，i3和&amp;ri是declarator。</span></span><br><span class="line"><span class="comment">// &amp;ri这个declarator给了变量名：ri，和type：int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> dp, *dp2; <span class="comment">// dp2 is a pointer to double; dp is a double</span></span><br><span class="line"><span class="comment">// double是base type，dp和*dp2是declarator。</span></span><br><span class="line"><span class="comment">// *dp2这个declarator给了变量名：dp2，和type：int*</span></span><br></pre></td></tr></table></figure>
<p><code>*</code>和<code>&amp;</code>是type
modifier，是declarator的一部分。type
modifier只作用在使用它的变量上，所以下面这个declaration，只有<code>p1</code>是pointer。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p1, p2; <span class="comment">// p1 is a pointer to int; p2 is an int</span></span><br></pre></td></tr></table></figure> type
modifier和变量名之间可以有空格，这也就造成了大家容易误解成<code>int*</code>
是所有后面变量的type。</p>
<p>之前我自己是更喜欢把<code>&amp;</code>和<code>*</code>跟base
type写在一起，看到这里之后决定还是改成跟变量名写在一起比较明白。</p>
<h2 id="reference">Reference</h2>
<p>A reference is an <strong>alias</strong>, <strong>not</strong> an
object. A reference is just another name for an already existing
object.</p>
<p>reference和它bind的object的type必须匹配（比如<code>double&amp;</code>
type不能bind一个<code>int</code>）。</p>
<p>一个reference只是一个名字，一个已有的object的另一个名字，reference没有自己的内存空间。</p>
<p>reference只能绑定（bind）到object上，不能绑定到字面值（literal）或者一个表达式的结果。</p>
<h2 id="pointer">Pointer</h2>
<p>pointer和它所指向的object的type必须匹配（比如<code>int*</code>
type不能指向一个<code>double</code>）。</p>
<p>Pointer如果定义在block scope（一般是函数体）里，跟之前的built-in
type的variable一样，如果没有给初始值，那它也是uninitialized，它的值是undefined
value。这样的Pointer是invalid。</p>
<p>建议：定义pointer的时候就初始化它</p>
<p>null pointer不指向任何object <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>; <span class="comment">// equivalent to int *p1 = 0;</span></span><br></pre></td></tr></table></figure></p>
<p>pointer可以直接用在condition里（如<code>if(pointer)</code>），如果pointer为0（<code>nullptr</code>）那就是false，其他为true。</p>
<p>两个pointer用==比较，如果他们指向相同的地址那就是true。</p>
<p>Invalid pointer用在condition里或者比较的行为是undefined。</p>
<h2 id="understanding-compound-type-declarations">Understanding Compound
Type Declarations</h2>
<p>因为reference不是object，所以pointer不能指向reference。但是pointer是object，所以reference可以bind到pointer。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ primer 英文版p58</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p; <span class="comment">// p is a pointer to int</span></span><br><span class="line"><span class="type">int</span> *&amp;r = p; <span class="comment">// r is a reference to the pointer p</span></span><br><span class="line">r = &amp;i; <span class="comment">// r refers to a pointer; assigning &amp;i to r makes p point to i</span></span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">// dereferencing r yields i, the object to which p points; changes i to 0</span></span><br></pre></td></tr></table></figure> （不会真有人喜欢写这种代码吧，什么情况下会写成这样……</p>
<h1 id="const-qualifier"><code>const</code> Qualifier</h1>
<p>const object必须给初始值（被初始化）。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ primer EN p59</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="built_in">get_size</span>(); <span class="comment">// ok: initialized at run time</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j = <span class="number">42</span>; <span class="comment">// ok: initialized at compile time</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> k; <span class="comment">// error: k is uninitialized const</span></span><br></pre></td></tr></table></figure></p>
<h3 id="const-objects-are-local-to-a-file">const Objects Are Local to a
File</h3>
<blockquote>
<p>the compiler will <strong>usually</strong> replace uses of the
variable with its corresponding value during compilation</p>
</blockquote>
<blockquote>
<p>To share a const object among multiple files, you must define the
variable as extern.</p>
</blockquote>
<p><code>const</code>
object默认只在当前文件可见。需要跨文件使用同一个object的话，要用<code>extern</code>。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ primer EN p60</span></span><br><span class="line"><span class="comment">// file_1.cc defines and initializes a const that is accessible to other files</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">// file_1.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize; <span class="comment">// same bufSize as defined in file_1.cc</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，<code>const</code>与<code>initializer</code>同时使用，只能在<code>global scope</code>里，也就是<code>file_1.cc</code>里的语句不能放在任何函数中。</p>
<p><code>file_1.h</code>里的语句是declaration，之前也提到过，一个变量是可以声明多次的，所以每在其他cpp文件里引用<code>file_1.h</code>就相当于声明了一次。</p>
<p>其实不引用<code>file_1.h</code>，直接在cpp文件里用<code>extern const int bufSize;</code>也是一样的效果，但是就会造成相同的代码复制到多个地方，以后如果要改就容易出错。</p>
<h2 id="reference-to-const">Reference to <code>const</code></h2>
<p>reference的类型和它绑定的object的类型需要匹配，但是有两个例外，这里是第一个例外：reference
to
<code>const</code>，可以用<code>literal</code>、表达式和non<code>const</code>
object初始化，还能用<em>可以转换成reference的类型的其他表达式</em>初始化</p>
<blockquote>
<p>we can initialize a reference to const from any expression that can
be converted (§ 2.1.2, p. 35) to the type of the reference. In
particular, we can bind a reference to const to a nonconst object, a
literal, or a more general expression</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i; <span class="comment">// we can bind a const int&amp; to a plain int object</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>; <span class="comment">// ok: r1 is a reference to const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>; <span class="comment">// ok: r3 is a reference to const</span></span><br><span class="line"><span class="type">int</span> &amp;r4 = r * <span class="number">2</span>; <span class="comment">// error: r4 is a plain, nonconst reference</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = dval;	<span class="comment">// OK, convert from double to int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri2 = <span class="number">3.14</span>;	<span class="comment">// OK, convert from double to int</span></span><br></pre></td></tr></table></figure>
<p>Reference to
const可以绑定nonconst的object，但是不能更改object的值。</p>
<h2 id="pointers-and-const">Pointers and const</h2>
<h3 id="pointer-to-const">pointer to <code>const</code></h3>
<p>pointer的类型需要和它指向的object的类型匹配，但有两个例外，这里是第一个。
我们可以用一个pointer to <code>const</code>指向一个non<code>const</code>
object <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ primer EN p62</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>; <span class="comment">// dval is a double; its value can be changed</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;dval; <span class="comment">// ok: but can’t change dval through cptr</span></span><br></pre></td></tr></table></figure>
从右往左读declaration更容易理解。<code>const double *cptr</code>：cptr是一个pointer，指向double
const。</p>
<h3 id="const-pointer">const pointer</h3>
<p>不同于reference，pointer自己也是一个object，所以pointer本身也可以是const。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ primer EN p63</span></span><br><span class="line"><span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumb; <span class="comment">// curErr will always point to errNumb</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi; <span class="comment">// pip is a const pointer to a const object</span></span><br></pre></td></tr></table></figure></p>
<h2 id="top-level-const">Top-Level const</h2>
<p>这个概念之前根本没接触过。</p>
<blockquote>
<p>top-level const indicates that an object itself is const. Top-level
const can appear in any object type, i.e., one of the built-in
arithmetic types, a class type, or a pointer type. Low-level const
appears in the base type of compound types such as pointers or
references.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ primer EN p64</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i; <span class="comment">// we can’t change the value of p1; const is top-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>; <span class="comment">// we cannot change ci; const is top-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci; <span class="comment">// we can change p2; const is low-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2; <span class="comment">// right-most const is top-level, left-most is not</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = ci; <span class="comment">// const in reference types is always low-level</span></span><br></pre></td></tr></table></figure>
<p>如果pointer是const
pointer，也就是指针指向的地址不能改变，这个const是top
level；如果pointer指向的object是const，这个const是low level。</p>
<p>reference只有low level
const，因为reference不可能改变绑定的object（也可以说reference本身就只能是const），const的区别也就只在于reference绑定的object是不是const。</p>
<blockquote>
<p>When we copy an object, top-level consts are ignored:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">i = ci; <span class="comment">// ok: copying the value of ci; top-level const in ci is ignored</span></span><br><span class="line">p2 = p3; <span class="comment">// ok: pointed-to type matches; top-level const in p3 is ignored</span></span><br></pre></td></tr></table></figure>
<p>在复制object的时候，top level const被忽略，nonconst当然可以赋值const
object的值，const初始化的时候也可以用nonconst的值。</p>
<h2 id="constexpr-and-constant-expressions"><code>constexpr</code> and
Constant Expressions</h2>
<h3 id="constant-expression">Constant expression</h3>
<blockquote>
<p>an expression whose value cannot change and that can be evaluated at
compile time.</p>
</blockquote>
<ul>
<li>A <strong>literal</strong> is a constant expression</li>
<li>A <strong>const object</strong> that is <strong>initialized</strong>
from a <strong>constant expression</strong> is also a constant
expression</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>; <span class="comment">// max_files is a constant expression</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_files + <span class="number">1</span>; <span class="comment">// limit is a constant expression</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>; <span class="comment">// staff_size is not a constant expression</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>(); <span class="comment">// sz is not a constant expression</span></span><br></pre></td></tr></table></figure>
<p>不懂为什么limit也是constant expression，两个constant
expression加法运算也是constant expression吗？</p>
<h3 id="constexpr-variables"><code>constexpr</code> Variables</h3>
<p>C++11,
用<code>constexpr</code>声明变量，编译器会帮我们检查这个变量是不是constant
expression。</p>
<p>用<code>constexpr</code>声明的variable，隐含着声明了它是<code>const</code>variable。（variable一般翻译成变量，但是const表示不变，const
variable意义互相矛盾就很奇怪了，直接翻译成<code>常量</code>）</p>
<p>用<code>constexpr</code>声明的variable，必须用constant
expression初始化。</p>
<h3 id="literal-types">Literal Types</h3>
<p>可以用<code>constexpr</code>的类型被叫做<code>literal types</code>。</p>
<p>目前<code>literal types</code>：</p>
<ul>
<li>arithmetic type</li>
<li>reference type</li>
<li>pointer type</li>
</ul>
<p>可以初始化<code>constexpr</code> pointer的expression：</p>
<ul>
<li>nullptr</li>
<li>literal 0</li>
<li>an object that remains at a fixed address</li>
</ul>
<p>函数里的variable没有固定地址，所以不能用来初始化<code>constexpr</code>
pointer。（static例外？）</p>
<h3 id="constexpr-pointer"><code>constexpr</code> pointer</h3>
<blockquote>
<p>constexpr imposes a <strong>top-level const</strong> (§ 2.4.3, p. 63)
on the objects it defines</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ primer EN p67</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">// p is a pointer to a const int</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">// q is a const pointer to int</span></span><br></pre></td></tr></table></figure>
<p><code>constexpr</code>
pointer一定是一个不能改变所指地址的pointer（const pointer）。</p>
<h1 id="dealing-with-types">Dealing with Types</h1>
<h2 id="type-alias">Type Alias</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ primer EN p67-68</span></span><br><span class="line"><span class="comment">// Two ways</span></span><br><span class="line"><span class="comment">// 1. typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages; <span class="comment">// wages is a synonym for double</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base is a synonym for double, p for double*</span></span><br><span class="line"><span class="comment">// 2. using</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">// SI is a synonym for Sales_item</span></span><br><span class="line"></span><br><span class="line">wages hourly, weekly; <span class="comment">// same as double hourly, weekly;</span></span><br><span class="line">SI item; <span class="comment">// same as Sales_item item</span></span><br></pre></td></tr></table></figure>
<h3 id="pointers-const-and-type-aliases">Pointers, const, and Type
Aliases</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;</span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// cstr is a constant pointer to char</span></span><br><span class="line"><span class="type">const</span> pstring *ps; <span class="comment">// ps is a pointer to a constant pointer to char</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cstr = <span class="number">0</span>; <span class="comment">// wrong interpretation of const pstring cstr</span></span><br></pre></td></tr></table></figure>
<p>需要注意： <code>const pstring cstr</code> 不等于
<code>const char *cstr</code></p>
<blockquote>
<p>a const that appears in the base type modifies the given type.</p>
</blockquote>
<blockquote>
<p>When we use pstring in a declaration, the base type of the
declaration is a pointer type.</p>
</blockquote>
<p>base type到底是什么？在chapter summary里给了定义： &gt; type
specifier, possibly qualified by const, that precedes the declarators in
a declaration. The base type provides the common type on which the
declarators in a declaration can build.</p>
<h2 id="the-auto-type-specifier">The <code>auto</code> Type
Specifier</h2>
<p>使用<code>auto</code>创建变量必须有初始值。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the type of item is deduced from the type of the result of adding val1 and val2</span></span><br><span class="line"><span class="keyword">auto</span> item = val1 + val2; <span class="comment">// item initialized to the result of val1 + val2</span></span><br></pre></td></tr></table></figure></p>
<p>跟其他type
specifier一样，可以使用一次auto定义多个变量，但是每个变量类型必须一致。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i; <span class="comment">// ok: i is int and p is a pointer to int</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>; <span class="comment">// error: inconsistent types for sz and pi</span></span><br></pre></td></tr></table></figure></p>
<h3 id="compound-types-const-and-auto">Compound Types, const, and
auto</h3>
<p>感觉auto碰上const，reference和pointer就变得有好复杂了</p>
<p>使用auto声明的变量的类型，不一定跟给它的初始值的类型一样。</p>
<p><strong>Reference</strong></p>
<p>使用reference作为初始值，auto推断出的类型是和reference绑定的类型相同。这意味着：
- 使用int &amp;类型的变量作为初始值，auto推测的类型是int。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">// a is an int (r is an alias for i, which has type int)</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Top-level consts</strong></p>
<p>auto忽略top-level consts。这意味着： - 使用const
int类型的变量作为初始值，auto推测的类型是int。因为这里const是top-level。
- 使用const int* 类型的变量作为初始值，auto推测的类型是const
int*。这里const是修饰int，而不是pointer，所以是low-level const。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci; <span class="comment">// b is an int (top-level const in ci is dropped)</span></span><br><span class="line"><span class="keyword">auto</span> c = cr; <span class="comment">// c is an int (cr is an alias for ci whose const is top-level)</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i; <span class="comment">// d is an int* (&amp; of an int object is int*)</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci; <span class="comment">// e is const int* (&amp; of a const object is low-level const)</span></span><br></pre></td></tr></table></figure></p>
<p>如果要得到top level const，需要显式声明<code>const auto</code>。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci; <span class="comment">// deduced type of ci is int; f has type const int</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Reference with top-level consts</strong></p>
<p>但是，如果用auto声明一个reference，那top level
const就不会被忽略了。这意味着： - 使用const
int类型的变量作为初始值，auto &amp;推测的类型是const int&amp;。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci; <span class="comment">// g is a const int&amp; that is bound to ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>; <span class="comment">// error: we can’t bind a plain reference to a literal</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>; <span class="comment">// ok: we can bind a const reference to a literal</span></span><br></pre></td></tr></table></figure></p>
<h3 id="auto后pointer-declarator">auto后pointer declarator</h3>
<p>在下面这种情况下加不加<code>*</code>效果是一样的 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> *p = &amp;i;	<span class="comment">// p is a pointer to int</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;	<span class="comment">// d is also a pointer to int</span></span><br></pre></td></tr></table></figure></p>
<p>但是和const一起用就不一样了…… &gt;
https://stackoverflow.com/a/40867640</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Const pointer to non-const int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> ip1 = &amp;i; <span class="comment">// int *const</span></span><br><span class="line">++ip1; <span class="comment">// error</span></span><br><span class="line">*ip1 = <span class="number">1</span>; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-const pointer to const int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>* ip2 = &amp;i; <span class="comment">// int const*</span></span><br><span class="line">++ip2; <span class="comment">// OK</span></span><br><span class="line">*ip2 = <span class="number">1</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<h2 id="the-decltype-type-specifier">The <code>decltype</code> Type
Specifier</h2>
<p>decltype是一个type
specifier，也就是用来声明、定义变量用的类型。但是它不需要像auto那样必须给初始值。</p>
<p>decltype通过给它的expression来判断类型，但并不会evaluate这个expression。（也就是说如果expression是个需要计算或者函数，decltype并不会执行这个计算或者调用函数，它只是通过expression分析计算或者函数将会返回什么类型）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Primer EN p70</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x; <span class="comment">// sum has whatever type f returns</span></span><br></pre></td></tr></table></figure>
<p>如果expression只是一个variable，decltype得到的就是这个variable的type，包括top-level
const和reference。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Primer EN p71</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;	<span class="comment">// cj is a reference to const int</span></span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>; <span class="comment">// x has type const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x; <span class="comment">// y has type const int&amp; and is bound to x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z; <span class="comment">// error: z is a reference and must be initialized</span></span><br></pre></td></tr></table></figure>
<h3 id="decltype-and-references"><code>decltype</code> and
References</h3>
<blockquote>
<p>Generally speaking, <code>decltype</code> returns a reference type
for expressions that yield objects that can stand on the left-hand side
of the assignment</p>
</blockquote>
<p>看下面的例子。因为我们可以给<code>*p</code>赋值，而且赋值改变的是p指向的object，所以decltype得到一个reference也很合理。
（如果decltype得到的是int类型，那么相当于新定义了一个变量，对新变量赋值不会影响原来的变量，这和<code>*p</code>的作用不符。）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p71</span></span><br><span class="line"><span class="comment">// decltype of an expression can be a reference type</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">// ok: addition yields an int; b is an (uninitialized) int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c; <span class="comment">// error: c is int&amp; and must be initialized</span></span><br></pre></td></tr></table></figure>
<p>如果在variable周围加上括号，那<code>decltype</code>得到的类型一定是reference。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p71</span></span><br><span class="line"><span class="comment">// decltype of a parenthesized variable is always a reference</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">// error: d is int&amp; and must be initialized</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e; <span class="comment">// ok: e is an (uninitialized) int</span></span><br></pre></td></tr></table></figure>
<h1 id="defining-our-own-data-structures">Defining Our Own Data
Structures</h1>
<p>Best Practices: &gt; Headers should have guards, even if they aren’t
(yet) included by another header.</p>
<p>所有的头文件都应该用guard。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ primer EN p77</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line">	std::string bookNo;</span><br><span class="line">	<span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="一些感想">一些感想</h1>
<p>虽然有很多知识盲区，现在才补上，但是就算不知道不还是这样工作快两年了，只能说目前工作里要处理的都是些业务逻辑，也很少需要细究C++基础知识。就算碰到什么不懂的语法，以前有搜索引擎，现在有chatgpt，工作总是能做的。</p>
<p>只是感觉这样做这对自己的能力也没太大提升，所以还是得回头看书系统地学一学。</p>
<p>不过之前看过一些观点说“系统学习”属于是学生思维了，我感觉也没错。如果让我一开始就看这本C++
Primer我也看不进去，反倒是现在工作一段时间觉得知识上有漏洞，带着比较强目的性看反而收获颇多。而且毕竟对语言熟悉了，看起来也不那么费劲。</p>
<p>总的来说还是实践更重要些，最好的还是快速入门然后做些项目，之后再来系统学习收获可能更多。</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>非常基础的荷兰语笔记 KUL荷兰语课笔记整理</title>
    <url>/2020/12/13/%E9%9D%9E%E5%B8%B8%E5%9F%BA%E7%A1%80%E7%9A%84%E8%8D%B7%E5%85%B0%E8%AF%AD%E7%AC%94%E8%AE%B0-KUL%E8%8D%B7%E5%85%B0%E8%AF%AD%E8%AF%BE%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>学了一个学期（其实也就三个月不到吧）的荷兰语，考试复习的时候记了一些笔记，这种小语种网上资料很少，所以把它分享出来，欢迎批评指正。所有内容都来自鲁汶大学的一本教材
《Vanzelfsprekend Deel 1-4 van Tekstboek》</p>
<span id="more"></span>
<h1 id="介词">介词</h1>
<h2 id="in">IN</h2>
<h3 id="时间">时间</h3>
<ul>
<li>+ week: in de tweede week van oktober</li>
<li>+ maand: in december</li>
<li>+ seizoen: in de winter</li>
<li>+ jaar: in 2020</li>
</ul>
<h3 id="地点">地点</h3>
<ul>
<li>+ straat: in de Naamsestraat</li>
<li>+ 城市: in Leuven, in Brussel</li>
</ul>
<h2 id="op">OP</h2>
<h3 id="时间-1">时间</h3>
<p>+ dag: op maandag, op 26 september</p>
<h3 id="地点-1">地点</h3>
<ul>
<li>+ plein: op het Ladeuzeplein</li>
<li>+ nummer: op nummer 10</li>
</ul>
<h3 id="其他">其他</h3>
<ul>
<li>op een feestje</li>
<li>op de luchthaven</li>
<li>op vakantie</li>
</ul>
<h2 id="om">OM</h2>
<h3 id="时间-2">时间</h3>
<ul>
<li>+ uur: om vijf uur, om halfvijf, om kwart voor vijf</li>
</ul>
<h2 id="aan">AAN</h2>
<p>Anna werkt aan de universiteit.</p>
<h2 id="bij">BIJ</h2>
<p>Peter werkt bij een computerfirma.</p>
<h2 id="met">MET</h2>
<p>An gaat met de fiets naar de universiteit.</p>
<h2 id="naar">NAAR</h2>
<p>gaan (…) naar …</p>
<h2 id="over">OVER</h2>
<ul>
<li>Ik ben 27 jaar. Over 3 jaar word ik 30 jaar.</li>
<li>Over 15 minuten vertrekt de trein.</li>
</ul>
<h1 id="数字">数字</h1>
<table>
<thead>
<tr>
<th>0 nul</th>
<th>10 tien</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1 één</td>
<td>11 elf</td>
<td></td>
<td>41 eenenveertig</td>
</tr>
<tr>
<td>2 twee</td>
<td>12 twaalf</td>
<td>20 twintig</td>
<td>42 tweeënveertig</td>
</tr>
<tr>
<td>3 drie</td>
<td>13 dertien</td>
<td>30 dertig</td>
<td>43 drieënveertig</td>
</tr>
<tr>
<td>4 vier</td>
<td>14 veertien</td>
<td>40 veertig</td>
<td>44 vierenveertig</td>
</tr>
<tr>
<td>5 vijf</td>
<td>15 vijftien</td>
<td>50 vijftig</td>
<td>45 vijfenveertig</td>
</tr>
<tr>
<td>6 zes</td>
<td>16 zestien</td>
<td>60 zestig</td>
<td>46 zesenveertig</td>
</tr>
<tr>
<td>7 zeven</td>
<td>17 zeventien</td>
<td>70 zeventig</td>
<td>47 zevenenveertig</td>
</tr>
<tr>
<td>8 acht</td>
<td>18 achttien</td>
<td>80 tachtig</td>
<td>48 achtenveertig</td>
</tr>
<tr>
<td>9 negen</td>
<td>19 negentien</td>
<td>90 negentig</td>
<td>49 negenenveertig</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>100</th>
<th>honderd</th>
</tr>
</thead>
<tbody>
<tr>
<td>400</td>
<td>vierhonderd</td>
</tr>
<tr>
<td>1000</td>
<td>duizend</td>
</tr>
<tr>
<td>1100</td>
<td>duizend honderd (elfhonderd)</td>
</tr>
<tr>
<td>1800</td>
<td>duizend achthonderd (achttienhonderd)</td>
</tr>
<tr>
<td>2000</td>
<td>tweeduizend</td>
</tr>
<tr>
<td>2300</td>
<td>tweeduizend driehonderd</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>101 honderd(en)één</th>
<th>1001 duizend (en) één</th>
</tr>
</thead>
<tbody>
<tr>
<td>110 honderd(en)tien</td>
<td>1002 duizend (en) twee</td>
</tr>
<tr>
<td>111 honderd(en)elf</td>
<td>1011 duizend (en) elf</td>
</tr>
<tr>
<td>112 honderd(en)twaalf</td>
<td>1012 duizend (en) twaalf</td>
</tr>
<tr>
<td>113 honderddertien</td>
<td>1013 duizend dertien</td>
</tr>
<tr>
<td>114 honderdveertien</td>
<td>1014 duizend veertien</td>
</tr>
<tr>
<td>129 honderdnegenentwintig</td>
<td>1029 duizend negenentwintig</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>1.000.000</th>
<th>één miljoen</th>
</tr>
</thead>
<tbody>
<tr>
<td>10.000.000</td>
<td>tien miljoen</td>
</tr>
<tr>
<td>1.000.000.000</td>
<td>één miljard</td>
</tr>
</tbody>
</table>
<h2 id="序数词">序数词</h2>
<table>
<thead>
<tr>
<th>1ste eerste</th>
<th>6de zesde</th>
<th>11de elfde</th>
</tr>
</thead>
<tbody>
<tr>
<td>2de tweede</td>
<td>7de zevende</td>
<td>12de twaalfde</td>
</tr>
<tr>
<td>3de derde</td>
<td>8ste achtste</td>
<td>13de dertiende</td>
</tr>
<tr>
<td>4de vierde</td>
<td>9de negende</td>
<td>14de veertiende</td>
</tr>
<tr>
<td>5de vijfde</td>
<td>10de tiende</td>
<td>15de vijftiende</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>16de zestinede</th>
<th>21ste eenentwintigste</th>
<th>30ste dertigste</th>
</tr>
</thead>
<tbody>
<tr>
<td>17de zeventiende</td>
<td>22ste tweeëntwintigste</td>
<td>31ste eenendertigste</td>
</tr>
<tr>
<td>18de achttiende</td>
<td>23ste drieëntwintigste</td>
<td></td>
</tr>
<tr>
<td>19de negentiende</td>
<td>24ste vierentwintigste</td>
<td></td>
</tr>
<tr>
<td>20ste twintigste</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="时间和日期">时间和日期</h1>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>0.5</th>
<th>1.5</th>
</tr>
</thead>
<tbody>
<tr>
<td>秒</td>
<td>1 seconde</td>
<td>2 seconden</td>
<td></td>
<td></td>
</tr>
<tr>
<td>分</td>
<td>1 minuut</td>
<td>2 minuten</td>
<td></td>
<td></td>
</tr>
<tr>
<td>时</td>
<td>1 uur</td>
<td>2 uur</td>
<td>een half uur</td>
<td>anderhalf uur</td>
</tr>
<tr>
<td>天</td>
<td>1 dag</td>
<td>2 dagen</td>
<td>een halve dag</td>
<td>anderhalve dag</td>
</tr>
<tr>
<td>周</td>
<td>1 week</td>
<td>2 weken</td>
<td></td>
<td></td>
</tr>
<tr>
<td>月</td>
<td>1 maand</td>
<td>2 maanden</td>
<td>een halve maand</td>
<td>anderhalve maand</td>
</tr>
<tr>
<td>年</td>
<td>1 jaar</td>
<td>2 jaar</td>
<td>een half jaar</td>
<td>anderhalf jaar</td>
</tr>
</tbody>
</table>
<h2 id="月份">月份</h2>
<ul>
<li>januari</li>
<li>februari</li>
<li>maart</li>
<li>april</li>
<li>mei</li>
<li>juni</li>
<li>juli</li>
<li>augustus</li>
<li>september</li>
<li>oktober</li>
<li>november</li>
<li>december</li>
</ul>
<h2 id="星期">星期</h2>
<ul>
<li>maandag</li>
<li>dinsdag</li>
<li>woensdag</li>
<li>donderdag</li>
<li>vrijdag</li>
<li>zaterdag</li>
<li>zondag</li>
</ul>
<h2 id="一天里的不同时间">一天里的不同时间</h2>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 20%" />
<col style="width: 37%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>de dag</th>
<th>overdag (by day)</th>
<th>vandaag (today)</th>
</tr>
</thead>
<tbody>
<tr>
<td>07:00</td>
<td>de morgen, <br>de ochtend</td>
<td>'s morgens,<br>'s ochtends <br>(in the morning)</td>
<td>vanmorgen,<br>vannochtend <br>(this morning)</td>
</tr>
<tr>
<td>10:00</td>
<td>de voormiddag</td>
<td>in de voormiddag, voor de middag</td>
<td></td>
</tr>
<tr>
<td>12:00</td>
<td>de middag</td>
<td>'s middags</td>
<td>vanmiddag</td>
</tr>
<tr>
<td>15:15</td>
<td>de namiddag</td>
<td>in de namiddag, <br>na de middag</td>
<td></td>
</tr>
<tr>
<td>20:07</td>
<td>de avond</td>
<td>'s avonds</td>
<td>vanavond</td>
</tr>
<tr>
<td>23:20</td>
<td>de nacht</td>
<td>'s nachts</td>
<td>vannacht</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 17%" />
<col style="width: 35%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr>
<th>vandaag</th>
<th>+1 dag <br>morgen</th>
<th>+2 dagen <br>voermorgen</th>
<th>+3 dagen <br>over drie dagen</th>
</tr>
</thead>
<tbody>
<tr>
<td>van de week,<br>deze week <br>(this week)</td>
<td>+1 week <br>volgende week</td>
<td>+2 weken <br>over twee weken, <br>over veertien dagen</td>
<td></td>
</tr>
<tr>
<td>vrijdag</td>
<td>volgende vrijdag</td>
<td>vrijdag over twee weken</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="时刻">时刻</h2>
<ul>
<li>九点 negen uur</li>
<li>九点五分 vijf over negen</li>
<li>九点十分 tien over negen</li>
<li>九点一刻 kwart over negen</li>
<li>九点二十 twintig over negen, tien voor halftien</li>
<li>九点二十五 vijf voor halftien</li>
<li>九点半 halftien</li>
<li>九点三十五 vijf over halftien</li>
<li>九点四十 tien over halftien, twintig voor tien</li>
<li>九点四十五 kwart voor tien</li>
<li>九点五十 tien voor tien</li>
<li>九点五十五 vijf voor tien</li>
</ul>
<h1 id="人称">人称</h1>
<table>
<thead>
<tr>
<th></th>
<th>主格</th>
<th>宾格</th>
<th>所有格</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一人称 单</td>
<td>ik</td>
<td>me / mij</td>
<td>mijn</td>
</tr>
<tr>
<td>第一人称 复</td>
<td>we / wij</td>
<td>ons</td>
<td>(de) onze / (het) ons</td>
</tr>
<tr>
<td>第二人称 单</td>
<td>je / jij</td>
<td>je / jou</td>
<td>je / jouw</td>
</tr>
<tr>
<td>第二人称 单 敬</td>
<td>u</td>
<td>u</td>
<td>uw</td>
</tr>
<tr>
<td>第二人称 复</td>
<td>jullie</td>
<td>jullie</td>
<td>jullie</td>
</tr>
<tr>
<td>第二人称 复 敬</td>
<td>u</td>
<td>u</td>
<td>uw</td>
</tr>
<tr>
<td>第三人称 单 男</td>
<td>hij</td>
<td>hem</td>
<td>zijn</td>
</tr>
<tr>
<td>第三人称 单 女</td>
<td>ze / zij</td>
<td>ze / haar</td>
<td>haar</td>
</tr>
<tr>
<td>第三人称 复</td>
<td>ze / zij</td>
<td>ze / hen</td>
<td>hun</td>
</tr>
</tbody>
</table>
<p>英语里的it在荷兰语里可能是het</p>
<h1 id="be动词zijn">be动词：zijn</h1>
<h2 id="单数">单数</h2>
<table>
<thead>
<tr>
<th>ik</th>
<th>je / jij</th>
<th>u</th>
<th>hij, ze / zij</th>
</tr>
</thead>
<tbody>
<tr>
<td>ben</td>
<td>bent</td>
<td>bent</td>
<td>is</td>
</tr>
</tbody>
</table>
<h2 id="复数">复数</h2>
<table>
<thead>
<tr>
<th>we / wij</th>
<th>jullie</th>
<th>u</th>
<th>ze / zij</th>
</tr>
</thead>
<tbody>
<tr>
<td>zijn</td>
<td>zijn</td>
<td>bent</td>
<td>zijn</td>
</tr>
</tbody>
</table>
<h1 id="助动词">助动词</h1>
<ul>
<li>willen: wish</li>
<li>mogen: permission</li>
<li>moeten: obligation</li>
<li>kunnen: ability; possibility</li>
<li>zullen: suggestion; future</li>
</ul>
<figure>
<img src="pic_1721590024834.png" alt="picture 0" />
<figcaption aria-hidden="true">picture 0</figcaption>
</figure>
<h1 id="指示代词">指示代词</h1>
<table>
<thead>
<tr>
<th></th>
<th>this / these</th>
<th>that / those</th>
</tr>
</thead>
<tbody>
<tr>
<td>is</td>
<td>dit is</td>
<td>dat is</td>
</tr>
<tr>
<td>are</td>
<td>dit zijn</td>
<td>dat zijn</td>
</tr>
</tbody>
</table>
<h1 id="形容词在dehet名词前的变化">形容词在de/het名词前的变化</h1>
<table>
<thead>
<tr>
<th></th>
<th>de</th>
<th>het</th>
</tr>
</thead>
<tbody>
<tr>
<td>which</td>
<td>welke</td>
<td>welk</td>
</tr>
<tr>
<td>half</td>
<td>halve</td>
<td>half</td>
</tr>
<tr>
<td>each</td>
<td>elke</td>
<td>elk</td>
</tr>
<tr>
<td>this</td>
<td>deze</td>
<td>dit</td>
</tr>
<tr>
<td>that</td>
<td>die</td>
<td>dat</td>
</tr>
</tbody>
</table>
<h1 id="疑问词">疑问词</h1>
<table>
<thead>
<tr>
<th>NL</th>
<th>EN</th>
</tr>
</thead>
<tbody>
<tr>
<td>wie</td>
<td>who</td>
</tr>
<tr>
<td>wat</td>
<td>what</td>
</tr>
<tr>
<td>waar</td>
<td>where</td>
</tr>
<tr>
<td>wanneer</td>
<td>when</td>
</tr>
<tr>
<td>hoe</td>
<td>how</td>
</tr>
<tr>
<td>Hoe heet je?</td>
<td>What’s your name? (How to call you?)</td>
</tr>
<tr>
<td>Hoe laat is het?</td>
<td>What time is it? (How late is it?)</td>
</tr>
<tr>
<td>Hoe ver is het?</td>
<td>How far is it?</td>
</tr>
<tr>
<td>Hoe oud is je?</td>
<td>How old are you?</td>
</tr>
<tr>
<td>hoeveel</td>
<td>how much / how many</td>
</tr>
<tr>
<td>hoelang</td>
<td>how long</td>
</tr>
<tr>
<td>hoe vaak</td>
<td>how often</td>
</tr>
<tr>
<td>tot hoe laat</td>
<td>till what time</td>
</tr>
</tbody>
</table>
<h1 id="简单句句子结构">简单句句子结构</h1>
<h2 id="主语-定动词-其他-结尾">1.主语 定动词 其他 结尾</h2>
<h2 id="定动词-主语-其他-结尾">2.（…） 定动词 主语 其他 结尾</h2>
<figure>
<img src="pic_1721590091014.png" alt="picture 1" />
<figcaption aria-hidden="true">picture 1</figcaption>
</figure>
<p>也就是说，定动词一般放在简单句的第二位，除了把定动词提到最前面变成疑问句的情况。</p>
<h2 id="有助动词的情况">3.有助动词的情况</h2>
<figure>
<img src="pic_1721590108153.png" alt="picture 2" />
<figcaption aria-hidden="true">picture 2</figcaption>
</figure>
<p>助动词放在第二位，原来的定动词放到结尾，变成不定式。</p>
<h2 id="频率词放在第三位">4.频率词放在第三位</h2>
<ul>
<li>Ik ga <strong>vaak</strong> naar dat café.</li>
<li>Hij eet <strong>nooit</strong> pizza.</li>
<li>Wij maken <strong>soms</strong> ons huiswerk.</li>
<li>Ze eten <strong>elke week</strong> frietjes.</li>
<li>Hij gaat <strong>drie keer per jaar</strong> naar Spanje.</li>
<li>Ik tennis <strong>twee keer per week</strong> met mijn
vrienden.</li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
  </entry>
  <entry>
    <title>auto item-declaration in Range-Based For Loop on a const</title>
    <url>/2024/07/26/auto-item-declaration-in-Range-Based-For-Loop-on-a-const/</url>
    <content><![CDATA[<p>在C++ Primer里有一道练习题：</p>
<p>Exercise 3.11: Is the following range <code>for</code> legal? If so,
what is the type of <code>c</code>? <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> string s = <span class="string">&quot;Keep out!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure> <span id="more"></span></p>
<p>直觉上<code>c</code>的类型应该是<code>const char&amp;</code>，但是怎么推理得到<code>c</code>的类型呢？细究起来确实花了一番功夫。</p>
<p>使用auto声明的变量必须要给初始值，而这里的语法没有给初始值。Range-Based
for
loop应该是一种语法糖，实际上编译器应该是当成普通的for循环来处理的。</p>
<p>从cppreference（https://en.cppreference.com/w/cpp/language/range-for）上可以得到印证。
Range-Based for
loop的一般形式（省略了不相关的部分）实际上等价于下面的for循环：</p>
<blockquote>
<p><code>for ( item-declaration : range-initializer ) statement</code></p>
<ul>
<li><code>item-declaration</code> - a declaration for each range
item</li>
<li><code>range-initializer</code> - an expression or brace-enclosed
initializer list</li>
<li><code>statement</code> - any statement (typically a compound
statement)</li>
</ul>
</blockquote>
<blockquote>
<p>The above syntax produces code <strong>equivalent</strong> to the
following (the variables and expressions wrapped in <code>/* */</code>
are for exposition only): <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; <span class="comment">/* range */</span> = range-initializer ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="comment">/* begin */</span> = <span class="comment">/* begin-expr */</span>, <span class="comment">/* end */</span> = <span class="comment">/* end-expr */</span>;</span><br><span class="line">            <span class="comment">/* begin */</span> != <span class="comment">/* end */</span>; ++<span class="comment">/* begin */</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        item-declaration = *<span class="comment">/* begin */</span>;</span><br><span class="line">        statement</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Exposition-only expressions <code>/* begin-expr */</code> and
<code>/* end-expr */</code> are defined as follows:</p>
<p>If the type of <code>/* range */</code> is a reference to a class
type C, and searches in the scope of C for the names “begin” and “end”
each find at least one declaration, then <code>/* begin-expr */</code>
is <code>/* range */.begin()</code> and <code>/* end-expr */</code> is
<code>/* range */.end()</code>.</p>
</blockquote>
<p>在习题里，<code>range-initializer</code>对应的是<code>s</code>，<code>item-declaration</code>是<code>auto &amp;c</code>。<code>s</code>类型是<code>std::string</code>，是<code>class type</code>，而<code>std::string</code>也确实定义了<code>begin</code>和<code>end</code>函数，所以<code>/* begin-expr */</code>和<code>/* end-expr */</code>就是<code>string::begin()</code>和<code>string::end()</code>。</p>
<p>那么<code>string::begin()</code>的返回值就决定了<code>c</code>的类型。cppreference（https://en.cppreference.com/w/cpp/string/basic_string/begin）可以看到函数签名<code>const_iterator begin() const;</code>。因为<code>s</code>是<code>const string</code>，所以我们关注的是<code>const</code>函数。</p>
<p>根据cppreference（https://en.cppreference.com/w/cpp/string/basic_string，https://en.cppreference.com/w/cpp/named_req/Iterator），<code>const_iterator</code>是一种<code>LegacyIterator</code>，而iterator可以被看作是指针的一种抽象。</p>
<blockquote>
<p><code>LegacyRandomAccessIterator</code> and
<code>LegacyContiguousIterator</code> to <code>const value_type</code>
Iterators can be thought of as an abstraction of pointers.</p>
</blockquote>
<p>cppreference
<code>LegacyRandomAccessIterator</code>的页面（https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator）提到，如果iterator是来自一个container，那dereference这个iterator得到的object的类型就是containter的<code>value_type</code>。</p>
<blockquote>
<p>If a LegacyRandomAccessIterator it originates from a Container, then
it's value_type is the same as the container's, so dereferencing (*it)
obtains the container's value_type.</p>
</blockquote>
<p>那么string是不是一个Container呢？cppreference说它满足AllocatorAwareContainer、SequenceContainer、ContiguousContainer的要求，那么我们也可以说string是一种container。</p>
<blockquote>
<p>std::basic_string satisfies the requirements of
<code>AllocatorAwareContainer</code> (except that customized
construct/destroy are not used for construction/destruction of
elements), <code>SequenceContainer</code> and
<code>ContiguousContainer(since C++17)</code>.</p>
</blockquote>
<p>（不过<code>LegacyContiguousIterator</code>（https://en.cppreference.com/w/cpp/named_req/ContiguousIterator）没有提到dereference该怎么办，或者是我看漏了，这里也只能先忽略这种情况了）</p>
<p><code>const_iterator</code>指向的是<code>const value_type</code>。<code>std::string</code>实际上是<code>std::basic_string&lt;char&gt;</code>，而<code>value_type</code>就是<code>char</code>。所以对<code>const_iterator</code>
dereference（<code>*it</code>）的话得到的object类型是<code>const char</code>。</p>
<p>一般情况下，<code>auto</code>会忽略top-level
consts。但是如果用<code>auto</code>声明一个reference，那top-level
<code>const</code>就不会被忽略了。习题的情况正是后者，所以<code>c</code>的类型是<code>const char&amp;</code>。</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ primer ch3 - Strings, Vectors, and Arrays 阅读笔记</title>
    <url>/2024/07/30/C-primer-ch3-Strings-Vectors-and-Arrays-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="namespace-using-declarations">3.1 Namespace using
Declarations</h1>
<blockquote>
<p>A Separate using Declaration Is Required for Each Name. The important
part is that there must be a using declaration for each name we use, and
each declaration must end in a semicolon.</p>
</blockquote>
<p>C++ Primer第五版只是介绍C++11，那时候还只能用<code>using</code>
declarations一个个声明需要的name，但是C++17已经支持comma-separated list
in using-declaration。</p>
<blockquote>
<p>https://en.cppreference.com/w/cpp/language/using_declaration</p>
</blockquote>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// using declarations for names from the standard library</span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;    <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout, std::endl;    <span class="comment">// Wrong in C++11, but available from C++17</span></span><br></pre></td></tr></table></figure>
<h2 id="headers-should-not-include-using-declarations">Headers Should
Not Include using Declarations</h2>
<p>头文件在预处理的时候会被直接复制到用<code>#include</code>的那一行，所以在头文件里用using
declaration就相当于在（引用了头文件的）cpp里用，可能会意外地导致命名冲突。</p>
<h1 id="library-string-type">3.2 Library <code>string</code> Type</h1>
<h2 id="defining-and-initializing-strings">3.2.1 Defining and
Initializing <code>string</code>s</h2>
<p>用string literal初始化<code>string</code>，literal尾部的null
character不会被复制到<code>string</code>里。</p>
<h3 id="copy-initialization">copy initialization</h3>
<p>When we initialize a variable using =, we are asking the compiler to
copy initialize</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s5 = <span class="string">&quot;hiya&quot;</span>; <span class="comment">// copy initialization</span></span><br></pre></td></tr></table></figure>
<h3 id="direct-initialization">direct initialization</h3>
<p>when we omit the =, we use direct initialization</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(<span class="string">&quot;hiya&quot;</span>)</span></span>; <span class="comment">// direct initialization</span></span><br><span class="line"><span class="function">string <span class="title">s7</span><span class="params">(<span class="number">10</span>, ’c’)</span></span>; <span class="comment">// direct initialization; s7 is cccccccccc</span></span><br></pre></td></tr></table></figure>
<h3 id="copy-initialization-with-multi-value-initializer">copy
initialization with multi-value initializer</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s8 = <span class="built_in">string</span>(<span class="number">10</span>, ’c’); <span class="comment">// copy initialization; s8 is cccccccccc</span></span><br></pre></td></tr></table></figure>
<p>上面copy initialization其实新建了一个临时变量，相当于下面的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">temp</span><span class="params">(<span class="number">10</span>, ’c’)</span></span>; <span class="comment">// temp is cccccccccc</span></span><br><span class="line">string s8 = temp; <span class="comment">// copy temp into s8</span></span><br></pre></td></tr></table></figure>
<h2 id="operations-on-strings">3.2.2 Operations on
<code>string</code>s</h2>
<h3 id="reading-and-writing-strings">Reading and Writing
<code>string</code>s</h3>
<p><code>string</code> input operator (<code>&gt;&gt;</code>)
会忽略开头的所有whitespace（空格、换行、tab）。</p>
<h3 id="the-stringsize_type-type">The <code>string::size_type</code>
Type</h3>
<p><code>string</code>的<code>size</code>，类型是<code>string::size_type</code>。不确定具体的类型，但是一定是<code>unsigned</code>。</p>
<p>在用for循环遍历string的时候，循环变量也最好用<code>string::size_type</code>，或者用decltype和size()。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p94</span></span><br><span class="line"><span class="comment">// process characters in s until we run out of characters or we hit a whitespace</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) index = <span class="number">0</span>;</span><br><span class="line">    index != s.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isspace</span>(s[index]); ++index)</span><br><span class="line">        s[index] = <span class="built_in">toupper</span>(s[index]); <span class="comment">// capitalize the current character</span></span><br></pre></td></tr></table></figure></p>
<p>（但是以前从来没在意<code>size_type</code>，都是直接用<code>int i</code>循环了。）</p>
<h2 id="dealing-with-the-characters-in-a-string">3.2.3 Dealing with the
Characters in a <code>string</code></h2>
<h3 id="advice-use-the-c-versions-of-c-library-headers">ADVICE: USE THE
C++ VERSIONS OF C LIBRARY HEADERS</h3>
<p>C++ library包含了C library。C
library里头文件是以name.h格式命名的，在C++
library里头文件则是用cname命名的。如<code>ctype.h</code>,
<code>cctype</code>。</p>
<p>C++ library头文件里的成员（函数名、变量名之类的）都是定义在std
namespace里的，而C
library则不是。所以在C++程序里推荐用C++版本的library，避免命名冲突。</p>
<h3 id="processing-only-some-characters">Processing Only Some
Characters?</h3>
<p>subscript operator (the <code>[] operator</code>): The result of
using an out-of-range subscript is <strong>undefined</strong>.</p>
<h3 id="processing-every-character-use-range-based-for">Processing Every
Character? Use Range-Based <code>for</code></h3>
<p>Range-Based <code>for</code> （range for statement):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p91</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// print the characters in str one character to a line</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str) <span class="comment">// for every char in str</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl; <span class="comment">// print the current character followed by a newline</span></span><br></pre></td></tr></table></figure>
<h1 id="library-vector-type">3.3 Library <code>vector</code> Type</h1>
<p><code>vector</code>是一个<code>class template</code>，template本身不是一种类型，但是template给定元素的类型就可以生成新的类型，如<code>vector&lt;int&gt;</code>。</p>
<p>编译器从template创造class和function的过程叫做instantiation（实例化）。</p>
<p><code>vector</code>只能存objects，也就是说它不能存reference。</p>
<h2 id="defining-and-initializing-vectors">3.3.1 Defining and
Initializing <code>vector</code>s</h2>
<p>vector的复制：从旧vector复制每一个元素到新vector</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p97</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec2</span><span class="params">(ivec)</span></span>; <span class="comment">// copy elements of ivec into ivec2</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec3 = ivec; <span class="comment">// copy elements of ivec into ivec3</span></span><br></pre></td></tr></table></figure>
<h3 id="value-initialization">Value Initialization</h3>
<p>如果创建vector的时候只给定了size，那么vector里的元素会被<code>value-initialized</code>：</p>
<ul>
<li>如果元素是<code>built-in</code> type，那么会被初始化为0。</li>
<li>如果是<code>class</code>
type，那么会被<code>default initialized</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p98</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// ten elements, each initialized to 0</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// ten elements, each an empty string</span></span><br></pre></td></tr></table></figure>
<h3 id="list-initializer-or-element-count">List Initializer or Element
Count?</h3>
<blockquote>
<p>When we use curly braces, {...}, we’re saying that, if possible, we
want to list initialize the object. That is, if there is a way to use
the values inside the curly braces as a list of element initializers,
the class will do so. Only if it is not possible to list initialize the
object will the other ways to initialize the object be considered.</p>
</blockquote>
<p>如果使用花括号<code>&#123;&#125;</code>来初始化一个vector，那么编译器优先看能不能用List
initialization。如果不行，那再考虑其他的初始化方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p100</span></span><br><span class="line">vector&lt;string&gt; v5&#123;<span class="string">&quot;hi&quot;</span>&#125;; <span class="comment">// list initialization: v5 has one element</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v6</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>; <span class="comment">// error: can’t construct a vector from a string literal</span></span><br><span class="line">vector&lt;string&gt; v7&#123;<span class="number">10</span>&#125;; <span class="comment">// v7 has ten default-initialized elements</span></span><br><span class="line">vector&lt;string&gt; v8&#123;<span class="number">10</span>, <span class="string">&quot;hi&quot;</span>&#125;; <span class="comment">// v8 has ten elements with value &quot;hi&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的例子，<code>v8</code>正常的初始化写法应该是<code>v8(10, "hi")</code>，但是这里用花括号，表明我们想用list
initializer，但是花括号里值的类型都不同，不可能是list
initializer，所以编译器尝试其他的初始化方法（此处的情况是direct
initialization）。</p>
<h2 id="adding-elements-to-a-vector">3.3.2 Adding Elements to a
<code>vector</code></h2>
<p><strong>KEY CONCEPT: VECTORS GROW EFFICIENTLY</strong></p>
<blockquote>
<p>The standard requires that vector implementations can efficiently add
elements at run time. Because vectors grow efficiently, it is often
unnecessary—and can result in poorer performance—to define a vector of a
specific size.</p>
</blockquote>
<p>C++标准要求vector的实现要能在运行时高效地添加元素，所以通常没有必要在创建vector的时候指定size。</p>
<p>indirection operator <code>*</code>
https://en.cppreference.com/w/cpp/language/operator_member_access</p>
<blockquote>
<p>The operand of the built-in indirection operator must be pointer to
object or a pointer to function, and the result is the
<code>lvalue referring</code> to the object or function to which expr
points.</p>
</blockquote>
<h3
id="programming-implications-of-adding-elements-to-a-vector">Programming
Implications of Adding Elements to a <code>vector</code></h3>
<p>range for 的body里不能改变正在被遍历的vector的size</p>
<h2 id="other-vector-operations">3.3.3 Other <code>vector</code>
Operations</h2>
<p>我们可以比较<code>vector</code>s，前提是两个vector的元素类型相同。</p>
<blockquote>
<ul>
<li><code>v1 == v2</code>, <code>v1 != v2</code>: v1 and v2 are equal if
they have the same number of elements and each element in v1 is equal to
the corresponding element in v2.</li>
<li><code>&lt;, &lt;=, &gt;, &gt;=</code>: Have their normal meanings
using dictionary ordering.</li>
</ul>
</blockquote>
<h1 id="introducing-iterators">3.4 Introducing Iterators</h1>
<blockquote>
<p>Technically speaking, a string is not a container type, but string
supports many of the container operations.</p>
</blockquote>
<p>尽管从技术上来讲，<code>string</code>不是一种container，但是container支持的很多操作string也支持。</p>
<p>和pointer类似，iterator也能让我们indirect access to an object。</p>
<p>一个valid iterator：</p>
<ul>
<li>要么指向一个元素</li>
<li>要么指向container的最后一个元素之后一位（one past the last
element）。</li>
</ul>
<h2 id="using-iterators">3.4.1 Using Iterators</h2>
<p>拥有iterator的类型都会有返回iterator的（成员）函数，其中两个是<code>begin</code>和<code>end</code>。</p>
<ul>
<li><code>begin</code>返回的iterator指向第一个元素。</li>
<li><code>end</code>返回的iterator指向的位置是<strong>one past the
end</strong>。通常也被叫做<strong>off-the-end
iterator</strong>，或简称为 <strong>end iterator</strong>。</li>
</ul>
<p>如果container是空的，那么begin和end返回的iterator都是off-the-end
iterator。</p>
<blockquote>
<p>In general, we do not know (or care about) the precise type that an
iterator has.</p>
</blockquote>
<p>一般来说，我们<strong>不知道</strong>，<strong>也不关心</strong>iterator确切的类型。</p>
<h3 id="iterator-operations">Iterator Operations</h3>
<p>Dereference（解引用） invalid iterator或者off-the-end
iterator都是undefined behavior。</p>
<blockquote>
<p><code>*iter</code> Returns a <strong>reference</strong> to the
element denoted by the iterator iter.</p>
</blockquote>
<p>对iterator dereference得到的是<strong>reference</strong>！</p>
<blockquote>
<p><code>iter1 == iter2</code>, <code>iter1 != iter2</code>: Compares
two iterators for equality (inequality). Two iterators are equal if they
denote the same element or if they are the off-the-end iterator for the
same container.</p>
</blockquote>
<p>两个iterator相等，意味着</p>
<ul>
<li>要么他们指向相同的元素</li>
<li>要么他们是同一个container的off-the-end iterator</li>
</ul>
<h3 id="moving-iterators-from-one-element-to-another">Moving Iterators
from One Element to Another</h3>
<ul>
<li><code>++iter</code> Increments iter to refer to the next element in
the container.</li>
<li><code>--iter</code> Decrements iter to refer to the previous element
in the container.</li>
</ul>
<p>end返回的iterator不指向任何元素，所以不能对它<code>++</code>，也不能dereference。(但是可以<code>--</code>)。</p>
<h3 id="iterator-types">Iterator Types</h3>
<p>std library的container定义了它的iterator的类型：<code>iterator</code>
and <code>const_iterator</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p108</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it; <span class="comment">// it can read and write vector&lt;int&gt; elements</span></span><br><span class="line">string::iterator it2; <span class="comment">// it2 can read and write characters in a string</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3; <span class="comment">// it3 can read but not write elements</span></span><br><span class="line">string::const_iterator it4; <span class="comment">// it4 can read but not write characters</span></span><br></pre></td></tr></table></figure>
<h3 id="the-begin-and-end-operations">The <code>begin</code> and
<code>end</code> Operations</h3>
<p>对于non
const的container，也可以用<code>cbegin</code>，<code>cend</code>获得<code>const_iterator</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p109</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>(); <span class="comment">// it3 has type vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>
<h3 id="combining-dereference-and-member-access">Combining Dereference
and Member Access</h3>
<blockquote>
<p><code>it-&gt;mem</code> is a synonym for <code>(*it).mem</code></p>
</blockquote>
<h3 id="some-vector-operations-invalidate-iterators">Some vector
Operations Invalidate Iterators</h3>
<p>任何改变vector size的操作都会使所有iterator失效（invalid）。</p>
<h2 id="iterator-arithmetic">3.4.2 Iterator Arithmetic</h2>
<p>string和vector的iterator支持一些额外的操作：</p>
<blockquote>
<ul>
<li><code>iter + n</code>, <code>iter - n</code>: Adding (subtracting)
an integral value n to (from) an iterator yields an iterator that many
elements forward (backward) within the container. The resulting iterator
must denote elements in, or one past the end of, the same
container.</li>
<li><code>iter1 += n</code>, <code>iter1 -= n</code>:
Compound-assignment for iterator addition and subtraction. Assigns to
iter1 the value of adding n to, or subtracting n from, iter1.</li>
<li><code>iter1 - iter2</code>: Subtracting two iterators yields the
number that when added to the right-hand iterator yields the left-hand
iterator. The iterators must denote elements in, or one past the end of,
the same container.</li>
<li><code>&gt;, &gt;=, &lt;, &lt;=</code>: Relational operators on
iterators. One iterator is less than another if it refers to an element
that appears in the container before the one referred to by the other
iterator. The iterators must denote elements in, or one past the end of,
the same container.</li>
</ul>
</blockquote>
<p>两个iterator相减，或者要比较两个iterator的大小，他们必须是来自同一个container。</p>
<p>两个iterator相减，结果的类型是<code>difference_type</code>，是一种<code>singed integral</code>。</p>
<h1 id="arrays">3.5 Arrays</h1>
<h2 id="defining-and-initializing-built-in-arrays">3.5.1 Defining and
Initializing Built-in Arrays</h2>
<p>Array是一种<code>compound type</code>。</p>
<p>dimension指定了array的元素个数。而array的<strong>元素个数</strong>是array类型的<strong>一部分</strong>。因此dimension必须在编译时就已知，也就是说，dimension必须是<strong>constant
expression</strong>。</p>
<p>在函数体中声明的array，如果没有初始化，会被default-initialized。array中的元素的值是<strong>undefined
values</strong>。</p>
<p>不能用<code>auto</code>创建array。</p>
<p>array只能存object，也就是说不能存reference。</p>
<h3 id="explicitly-initializing-array-elements">Explicitly Initializing
Array Elements</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p114</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> ia1[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">// array of three ints with values 0, 1, 2</span></span><br><span class="line"><span class="type">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// an array of dimension 3</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// equivalent to a3[] = &#123;0, 1, 2, 0, 0&#125;</span></span><br><span class="line">string a4[<span class="number">3</span>] = &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span>&#125;; <span class="comment">// same as a4[] = &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;</span></span><br><span class="line"><span class="type">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">// error: too many initializers</span></span><br></pre></td></tr></table></figure>
<p>声明array的时候dimension可以不填，但是这样就必须给初始值（list
initialize），编译器可以推断array的size。</p>
<p>如果声明array时给的dimension比initializer
list里元素的个数更多，那么是剩下的元素会被<strong>value
initialized</strong>。</p>
<h3 id="character-arrays-are-special">Character Arrays Are Special</h3>
<p>如果用string literal来初始化char array，那么在数组末尾会增加一个null
character（<code>\0</code>）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p114</span></span><br><span class="line"><span class="type">char</span> a3[] = <span class="string">&quot;C++&quot;</span>; <span class="comment">// null terminator added automatically</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> a4[<span class="number">6</span>] = <span class="string">&quot;Daniel&quot;</span>; <span class="comment">// error: no space for the null!</span></span><br></pre></td></tr></table></figure>
<h3 id="no-copy-or-assignment">No Copy or Assignment</h3>
<p>不能用一个array去初始化另一个array. 有一些编译器可能支持array
assignment，但是并不是标准规定的特性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// array of three ints</span></span><br><span class="line"><span class="type">int</span> a2[] = a; <span class="comment">// error: cannot initialize one array with another</span></span><br><span class="line">a2 = a; <span class="comment">// error: cannot assign one array to another</span></span><br></pre></td></tr></table></figure>
<h3 id="understanding-complicated-array-declarations">Understanding
Complicated Array Declarations</h3>
<p>看螺旋法则吧（Clockwise/Spiral
Rule）（https://c-faq.com/decl/spiral.anderson.html）</p>
<blockquote>
<p>There are three simple steps to follow:</p>
<p>Starting with the unknown element, move in a spiral/clockwise
direction; when ecountering the following elements replace them with the
corresponding english statements:</p>
<p>[X] or []</p>
<pre><code>   =&gt; Array X size of... or Array undefined size of... 
   </code></pre>
<p>(type1, type2)</p>
<pre><code>   =&gt; function passing type1 and type2 returning... 
   </code></pre>
<ul>
<li>=&gt; pointer(s) to...</li>
</ul>
<p>Keep doing this in a spiral/clockwise direction until all tokens have
been covered.</p>
<p>Always resolve anything in parenthesis first!</p>
</blockquote>
<blockquote>
<p>Example #1: Simple declaration</p>
<figure>
<img src="c5c1ca40258a7e3514a759ab99a2ef45.png" alt="picture 0" />
<figcaption aria-hidden="true">picture 0</figcaption>
</figure>
<p>Question we ask ourselves: What is <code>str</code>?</p>
<p><code>str</code> is an...</p>
<p>We move in a spiral clockwise direction starting with
<code>str</code> and the first character we see is a <code>[</code> so,
that means we have an array, so...</p>
<pre><code>   `str` is an array 10 of... </code></pre>
<p>Continue in a spiral clockwise direction, and the next thing we
encounter is the <code>*</code> so, that means we have pointers,
so...</p>
<pre><code>   `str` is an array 10 of pointers to... </code></pre>
<p>Continue in a spiral direction and we see the end of the line (the
<code>;</code>), so keep going and we get to the type <code>char</code>,
so...</p>
<pre><code>   `str` is an array 10 of pointers to `char` </code></pre>
<p>We have now "visited" every token; therefore we are done!</p>
<p>Example #2: Pointer to Function declaration</p>
<figure>
<img src="54117011b1c1e3b480d6ecbd4131100d.png" alt="picture 1" />
<figcaption aria-hidden="true">picture 1</figcaption>
</figure>
<p>Question we ask ourselves: What is <code>fp</code>?</p>
<pre><code>`fp` is a... 

Moving in a spiral clockwise direction, the first thing we see is a `)`; therefore, fp is inside parenthesis, so we continue the spiral inside the parenthesis and the next character seen is the `*`, so...

    `fp` is a pointer to... 

We are now out of the parenthesis and continuing in a spiral clockwise direction, we see the `(`; therefore, we have a function, so...

    `fp` is a pointer to a function passing an int and a pointer to float returning... 

Continuing in a spiral fashion, we then see the `*` character, so...

    `fp` is a pointer to a function passing an int and a pointer to float returning a pointer to... 

Continuing in a spiral fashion we see the `;`, but we haven&#39;t visited all tokens, so we continue and finally get to the type `char`, so...

    `fp` is a pointer to a function passing an int and a pointer to float returning a pointer to a `char` </code></pre>
</blockquote>
<p>如果把*fp外的括号去掉会变成什么呢？</p>
<p><code>char **fp( int, float *);</code></p>
<p>fp就变成了：fp是一个function，这个function返回一个指针，这个指针指向一个指向char的指针</p>
<p>fp is a function (int, float *) returning a pointer to a pointer to
char</p>
<h2 id="accessing-the-elements-of-an-array">3.5.2 Accessing the Elements
of an Array</h2>
<p>用subscript访问array的元素，subscript的变量的类型是<code>size_t</code>，是一种<code>unsigned</code>类型。</p>
<h2 id="pointers-and-arrays">3.5.3 Pointers and Arrays</h2>
<p>当我们用array的时候，编译器通常会把array转换成pointer。</p>
<blockquote>
<p>when we use an object of array type, we are really using a pointer to
the first element in that array.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p117</span></span><br><span class="line">string nums[] = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;; <span class="comment">// array of strings</span></span><br><span class="line">string *p = &amp;nums[<span class="number">0</span>]; <span class="comment">// p points to the first element in nums</span></span><br><span class="line">string *p2 = nums; <span class="comment">// equivalent to p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure>
<p>当我们用array作为初始值，用auto定义一个变量的时候，编译器推断变量的类型是<strong>pointer</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p117</span></span><br><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; <span class="comment">// ia is an array of ten ints</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>; <span class="comment">// ia2 is an int* that points to the first element in ia</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the following is equivalent to the above</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(&amp;ia[<span class="number">0</span>])</span></span>; <span class="comment">// now it’s clear that ia2 has type int*</span></span><br></pre></td></tr></table></figure>
<p>但是如果用<code>decltype</code>，推断的类型不会发生转换，还是array。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p118</span></span><br><span class="line"><span class="comment">// ia3 is an array of ten ints</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">ia3 = p; <span class="comment">// error: can’t assign an int* to an array</span></span><br><span class="line">ia3[<span class="number">4</span>] = i; <span class="comment">// ok: assigns the value of i to an element in ia3</span></span><br></pre></td></tr></table></figure>
<h3 id="pointers-are-iterators">Pointers Are Iterators</h3>
<p>指向array的元素的pointer，支持和vector、string的iterator相同的操作（increment、decrement...）</p>
<h3 id="the-library-begin-and-end-functions">The Library begin and end
Functions</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p118</span></span><br><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; <span class="comment">// ia is an array of ten ints</span></span><br><span class="line"><span class="type">int</span> *beg = <span class="built_in">begin</span>(ia); <span class="comment">// pointer to the first element in ia</span></span><br><span class="line"><span class="type">int</span> *last = <span class="built_in">end</span>(ia); <span class="comment">// pointer one past the last element in ia</span></span><br></pre></td></tr></table></figure>
<p>当然也和iterator一样，不能dereference或者increment off-the-end
pointer</p>
<h3 id="pointer-arithmetic">Pointer Arithmetic</h3>
<p>pointer也可以用3.4.1和3.4.2里对iterator定义的操作。</p>
<p>两个pointer相减得到的结果的类型是<code>ptrdiff_t</code>，是一种<code>signed integral</code></p>
<p>null
pointer和指向非array的object的pointer，也可以用这些操作，虽然现在看起来好像没什么用。</p>
<h3 id="subcripts-and-pointers">Subcripts and Pointers</h3>
<p>可以看到array和pointer联系非常紧密。而且可以对pointer用subscript，subscript还可以是负值。</p>
<p>array用的是built-in subscript
operator，但是vector和string用的是他们类定义的operator，前者可以是负数，后者不行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;; <span class="comment">// array with 5 elements of type int</span></span><br><span class="line"><span class="type">int</span> i = ia[<span class="number">2</span>]; <span class="comment">// ia is converted to a pointer to the first element in ia</span></span><br><span class="line">            <span class="comment">// ia[2] fetches the element to which (ia + 2) points</span></span><br><span class="line"><span class="type">int</span> *p = ia; <span class="comment">// p points to the first element in ia</span></span><br><span class="line">i = *(p + <span class="number">2</span>); <span class="comment">// equivalent to i = ia[2]</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = &amp;ia[<span class="number">2</span>]; <span class="comment">// p points to the element indexed by 2</span></span><br><span class="line"><span class="type">int</span> j = p[<span class="number">1</span>]; <span class="comment">// p[1] is equivalent to *(p + 1),</span></span><br><span class="line">            <span class="comment">// p[1] is the same element as ia[3]</span></span><br><span class="line"><span class="type">int</span> k = p[<span class="number">-2</span>]; <span class="comment">// p[-2] is the same element as ia[0]</span></span><br></pre></td></tr></table></figure>
<h2 id="c-style-character-strings">3.5.4 C-Style Character Strings</h2>
<blockquote>
<p>Although C++ supports C-style strings, they should not be used by C++
programs. C-style strings are a surprisingly rich source of bugs and are
the root cause of many security problems. They’re also harder to
use!</p>
</blockquote>
<p>不推荐在C++程序里使用C-style字符串。</p>
<p>C-stlye
string是一个convention，这个convention是指怎样去表示和使用character
strings。遵循这个convention的string，使用character array，并以null
character （<code>\0</code>）结尾。</p>
<h3 id="c-library-string-functions">C Library String Functions</h3>
<blockquote>
<ul>
<li><code>strlen(p)</code> Returns the length of p, not counting the
null.</li>
<li><code>strcmp(p1, p2)</code> Compares p1 and p2 for equality. Returns
0 if p1 == p2, a positive value if p1 &gt; p2, a negative value if p1
&lt; p2.</li>
<li><code>strcat(p1, p2)</code> Appends p2 to p1. Returns p1.</li>
<li><code>strcpy(p1, p2)</code> Copies p2 into p1. Returns p1.</li>
</ul>
</blockquote>
<p>如果一个char
array的结尾不是null的话，用strlen的结果是<code>undefined</code></p>
<h3 id="comparing-strings">Comparing Strings</h3>
<p>比较C-style string要用<code>strcmp</code></p>
<p>使用普通的relational或者equality操作符（<code>&gt; &lt; = !=</code>...）去比较两个char
array的话，相当于比较两个不相关的pointer，结果是<code>undefined</code>。</p>
<p>Exercise 3.37: What does the following program do? <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> ca[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cp = ca;</span><br><span class="line"><span class="keyword">while</span> (*cp) &#123;</span><br><span class="line">    cout &lt;&lt; *cp &lt;&lt; endl;</span><br><span class="line">    ++cp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>'\0' null terminator，实际上<code>\</code>开头的escape
sequence。<code>\</code>可以接上1至3个八进制数字，表示的是一个字符的数值。</p>
<blockquote>
<p>Some examples (assumingthe Latin-1 character set):</p>
<p>\7 (bell) \12 (newline) \40 (blank)</p>
<p>\0 (null) \115 (’M’) 4d (’M’)</p>
</blockquote>
<p><code>\0</code>是null，数值上正好是0。所以如果用在字符串末尾，然后用指针遍历字符串，当遍历到<code>\0</code>的时候，因为数值为0就是false，循环就停止了。</p>
<h2 id="interfacing-to-older-code">3.5.5 Interfacing to Older Code</h2>
<h3 id="mixing-library-strings-and-c-style-strings">Mixing Library
strings and C-Style Strings</h3>
<p>可以用string
literal初始化一个<code>string</code>。可以通过c_str方法得到一个C-style
string。但是c_str返回的array并不会永远都是valid，当原本的string内容改变了，之前返回的array就失效了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>; <span class="comment">// s holds Hello World</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s.<span class="built_in">c_str</span>(); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h3 id="using-an-array-to-initialize-a-vector">Using an Array to
Initialize a vector</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p125</span></span><br><span class="line"><span class="type">int</span> int_arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// ivec has six elements; each is a copy of the corresponding element in int_arr</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copies three elements: int_arr[1], int_arr[2], int_arr[3]</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">subVec</span><span class="params">(int_arr + <span class="number">1</span>, int_arr + <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="advice-use-library-types-instead-of-arrays">ADVICE: USE LIBRARY
TYPES INSTEAD OF ARRAYS</h4>
<blockquote>
<p>Modern C++ programs should use vectors and iterators instead of
built-in arrays and pointers, and use strings rather than C-style
array-based character strings.</p>
</blockquote>
<h1 id="multidimensional-arrays">3.6 Multidimensional Arrays</h1>
<p>subscript的数量没有限制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// initialize all elements to 0</span></span><br><span class="line"><span class="comment">// int arr1[1][2][3][4]...</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>a two-dimensional array, the first dimension is usually referred to
as the <strong>row</strong> and the second as the
<strong>column</strong>.</p>
</blockquote>
<h2
id="initializing-the-elements-of-a-multidimensional-array">Initializing
the Elements of a Multidimensional Array</h2>
<p>多维数组的初始化，可以用多层list，也可以不用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p 126</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="comment">// three elements; each element is an array of size 4</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="comment">// initializers for the row indexed by 0</span></span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, <span class="comment">// initializers for the row indexed by 1</span></span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125; <span class="comment">// initializers for the row indexed by 2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent initialization without the optional nested braces for each row</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>但是如果每一行只想初始化部分元素的话，还是要用多层list，理所当然，不然的话就只是初始化前几个元素了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// explicitly initialize only element 0 in each row</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123; <span class="number">0</span> &#125;, &#123; <span class="number">4</span> &#125;, &#123; <span class="number">8</span> &#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// explicitly initialize row 0; the remaining elements are value initialized</span></span><br><span class="line"><span class="type">int</span> ix[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="subscripting-a-multidimensional-array">Subscripting a
Multidimensional Array</h2>
<p>如果提供的subscript数量少于定义数组时给的dimension，那么得到的会是内部的数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p127</span></span><br><span class="line"><span class="comment">// assigns the first element of arr to the last element in the last row of ia</span></span><br><span class="line">ia[<span class="number">2</span>][<span class="number">3</span>] = arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>]; <span class="comment">// binds row to the second four-element array in ia</span></span><br></pre></td></tr></table></figure>
<h2 id="using-a-range-for-with-multidimensional-arrays">Using a Range
<code>for</code> with Multidimensional Arrays</h2>
<p>如果使用range based
for遍历多维数组，那么除了最内层的array，外层的for循环都必须用reference</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia) <span class="comment">// for every element in the outer array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row) <span class="comment">// for every element in the inner array</span></span><br><span class="line">        cout &lt;&lt; col &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>如果外层for不用reference的话会怎样呢。因为range
for其实是个语法糖，编译器会转换成一个普通的for循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> row : ia)</span><br><span class="line"><span class="comment">// 上面相当于下面，省略了不相关内容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = <span class="built_in">begin</span>(ia) ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> row = *beg;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>begin(ia)</code>得到的是一个指向ia的第一个元素的指针，所以类型是一个指向有size为4的array的指针：<code>int (*p)[4]</code>。</p>
<p>而对<code>*beg</code>得到的就是一个reference，这个reference绑定的obect是一个size为4的array。</p>
<p>我们知道auto会忽略reference，而使用array相当于使用一个指向array第一个元素的指针，所以<code>auto row = *beg;</code>会让row的类型变成一个指向int的指针。</p>
<p>关于range based for更多内容，参考我另一篇range based for的笔记。</p>
<h2 id="pointers-and-multidimensional-arrays">Pointers and
Multidimensional Arrays</h2>
<blockquote>
<p>a multidimensional array is really an array of arrays, the pointer
type to which the array converts is a pointer to the first inner
array:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EN p129</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">// array of size 3; each element is an array of ints of size 4</span></span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>] = ia; <span class="comment">// p points to an array of four ints</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>]; <span class="comment">// p now points to the last element in ia</span></span><br></pre></td></tr></table></figure>
<h1 id="感想">感想</h1>
<p>这一章讲数组的内容占了很大篇幅，但是工作中几乎没见过用数组的，至少也是vector。可能在嵌入式里用的比较多？
而且数组很多情况下会被当成指针，多维数组就更复杂，感觉很容易出错，也不易读。书里也说了现代c++程序推荐用vector、iterator和string。</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Why std::cin can be used in while loop condition</title>
    <url>/2024/08/01/Why-std-cin-can-be-used-in-while-loop-condition/</url>
    <content><![CDATA[<p>当需要从命令行读取多个值的时候，有种常见的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (std::cin &gt;&gt; value) &#123;<span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>为什么while循环的condition可以用<code>std::cin &gt;&gt; value</code>？很明显这里需要的是一个bool值<code>std::cin &gt;&gt; value</code>是怎么转换成bool的呢？</p>
<h1 id="的返回值"><code>&gt;&gt;</code> 的返回值</h1>
<p>在cppreference上可以看到，cin的类型是<code>std::istream</code>（等同于<code>std::basic_istream&lt;char&gt;</code>），而且它是一个global
object；</p>
<p>顺着看std::istream，我们需要知道<code>&gt;&gt;</code>这个操作符返回了什么，查找到返回的类型是<code>std::basic_istream&amp;</code>，值就是cin它自己。</p>
<p>也就是说while
condition里现在有一个<code>std::basic_istream</code>类型的值，它要能转换成bool。</p>
<h1 id="conversion-operator">Conversion Operator</h1>
<p><code>std::basic_istream</code>（的基类std::basic_ios）确实定义了一个conversion
operator:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>stream有几种状态，当stream的状态是good，这个bool conversion
operator就返回true，其他状态，比如读到eof，读入的类型跟预期不同而出错等，都返回false。</p>
<p>但是还有一个问题，这个operator是explicit，也就是必须显式使用类型转换才能调用这个operator，如<code>static_cast&lt;int&gt;(std::cin &lt;&lt; value)</code>。</p>
<p>然而有一个例外，那就是如果一个表达式被用在condition里的话，编译器会对这个表达式自动应用explicit
conversion，while就是这个例外的一种。</p>
<p>explicit conversion会被自动应用的情况：</p>
<blockquote>
<ul>
<li>The condition of an if, while, or do statement</li>
<li>The condition expression in a for statement header</li>
<li>An operand to the logical NOT (<code>!</code>), OR
(<code>||</code>), or AND (<code>&amp;&amp;</code>) operators</li>
<li>The condition expression in a conditional (<code>?:</code>)
operator</li>
</ul>
</blockquote>
<h1 id="conclusion">Conclusion</h1>
<p>所以在while
condition里的使用形如<code>cin &gt;&gt; value</code>的语句，最后会调用一个将<code>std::basic_istream</code>类型转换为<code>bool</code>的explicit
conversion operator；而且因为在condition里，编译器会自动应用explicit
conversion，而不需要显式使用类型转换。</p>
<h1 id="references">References</h1>
<ul>
<li>https://en.cppreference.com/w/cpp/io/cin</li>
<li>https://en.cppreference.com/w/cpp/io/basic_istream</li>
<li>https://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt</li>
<li>https://en.cppreference.com/w/cpp/io/basic_ios/operator_bool</li>
<li>C++ Primer 5th Edition</li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ common initialization methods</title>
    <url>/2024/08/19/C-common-initialization-methods/</url>
    <content><![CDATA[<p>看完了C++ Primer part
I，看到了好几个初始化的方式，总是容易忘，翻来翻去也挺麻烦，而且本来也要写笔记，遂记录一下。</p>
<span id="more"></span>
<h1 id="default-initialization">Default Initialization</h1>
<p>当定义一个变量，但是没有显式地给初始值的时候，就会发生default
initialization。</p>
<ul>
<li>built-in types
<ul>
<li>如果一个built-in type的变量定义在global
scope，那么它会被初始化为0</li>
<li>如果它在local scope定义，那么它的值是<strong>undefined</strong></li>
</ul></li>
<li>class types
<ul>
<li>如果类有default constructor，就会调用这个default constructor</li>
<li>如果类没有定义default constructor，那么编译器会生成一个
<ul>
<li>如果member有in-class
initializer，那么生成的ctor会使用这个initializer</li>
<li>否则，member会进行default initialization</li>
</ul></li>
</ul></li>
<li>但是对于一个<strong>local
static</strong>变量，如果它的定义没有显式的初始化值，它会进行<strong>value
initialization</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// global scope</span></span><br><span class="line"><span class="type">int</span> x;  <span class="comment">// default initialization, x initialized to 0.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">// defualt initialization, x value undefined.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">1.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a; <span class="comment">// no default constructor, compiler generates one</span></span><br><span class="line">    <span class="comment">// a.x is default initialized to 0. a.y is initialized with in-class initializer 1.0.</span></span><br></pre></td></tr></table></figure>
<h1 id="value-initialization">Value Initialization</h1>
<blockquote>
<p>https://en.cppreference.com/w/cpp/language/value_initialization</p>
</blockquote>
<p>value
initialization发生在用空的圆括号<code>()</code>或者花括号<code>&#123;&#125;</code>来初始化变量的时候。当创建一个container，只给了size而没给初始值的时候，也会发生value
initialization。</p>
<ul>
<li>built-in types：被初始化为0</li>
<li>class types：如果类有default
constructor，会调用它来初始化；否则是错误</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x&#123;&#125;; <span class="comment">// x is initialized to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int x1(); // not a variable definition, it&#x27;s function declaration!</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *px = <span class="keyword">new</span> <span class="built_in">int</span>(); <span class="comment">// value initialization, px points to a int with value 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyStruct s&#123;&#125;; <span class="comment">// `s.a` is 0, `s.b` is 0.0 (members are zero-initialized)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyStruct s1(); // not a variable definition, it&#x27;s a function declaration!!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AnotherStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">AnotherStruct</span>(): <span class="built_in">a</span>() &#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// a will be value initialized to 0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ primer EN p98</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// ten elements, each initialized to 0</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// ten elements, each an empty string</span></span><br></pre></td></tr></table></figure>
<h1 id="direct-initialization">Direct Initialization</h1>
<p>direct
initialization用非空的圆括号<code>()</code>或者花括号<code>&#123;&#125;</code>来初始化变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// Directly initializes `x` with 10</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>; <span class="comment">// Directly initializes `str` with &quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="built_in">MyStruct</span>(<span class="type">int</span> x, <span class="type">double</span> y) : <span class="built_in">a</span>(x), <span class="built_in">b</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyStruct <span class="title">s</span><span class="params">(<span class="number">1</span>, <span class="number">2.5</span>)</span></span>; <span class="comment">// Calls MyStruct&#x27;s constructor</span></span><br></pre></td></tr></table></figure>
<h1 id="copy-initialization">Copy Initialization</h1>
<blockquote>
<p>https://en.cppreference.com/w/cpp/language/copy_initialization</p>
</blockquote>
<p>Copy initialization发生在：</p>
<ol type="1">
<li>用<code>=</code>来初始化变量的时候</li>
<li>调用函数时，函数的参数pass by value</li>
<li>函数的返回值return by value</li>
<li>发生异常时，throw or catch by value</li>
<li>aggregate initialization</li>
</ol>
<p>对于class types，copy initialization可能会调用copy
constructor，也可能会调用(implict) conversion
constructor，（还可能会调用move
constructor，不过目前还没看到这里，暂且按下不表）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyClass obj1;</span><br><span class="line">MyClass obj2 = obj1; <span class="comment">// copy constructor of MyClass will be called</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="comment">// Conversion constructor</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">MyClass obj = num; <span class="comment">// Calls MyClass(int x)</span></span><br></pre></td></tr></table></figure>
<h2 id="aggregate">Aggregate</h2>
<p>aggregate要么是数组类型，要么是一类特殊的class type。</p>
<p>如果是class type，那么这个class</p>
<ul>
<li>不能有user-defined consturctor</li>
<li>不能有private和protected member</li>
<li>不能有base class，也就是不能是继承自其他的类</li>
</ul>
<p>详细的定义在此：https://en.cppreference.com/w/cpp/language/aggregate_initialization</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Array initialization</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// Elements `1`, `2`, and `3` are copy-initialized to `arr[0]`, `arr[1]`, and `arr[2]`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Struct initialization</span></span><br><span class="line">    Point p = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;; <span class="comment">// `10` is copy-initialized to `p.x`, and `20` is copy-initialized to `p.y`</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Point: (&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="list-initialization">List Initialization</h1>
<p>list
initialization是C++11的新特性，它用花括号<code>&#123;&#125;</code>来初始化对象。之前在value
initialization里<code>int x&#123;&#125;;</code>和<code>MyStruct s&#123;&#125;;</code>就用到了list
initialization。</p>
<p>list initialization看着和aggregate
initialization很像，但是前者不止可以初始化aggregate，还可以用来初始化其他的类型，还可以用在函数的参数。</p>
<p>list initialization也分copy list / direct list
initialization，区别和之前 copy / direct initialization 类似。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    Point topLeft;</span><br><span class="line">    Point bottomRight;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span><br><span class="line">        : topLeft&#123;x1, y1&#125;, bottomRight&#123;x2, y2&#125; &#123;&#125;  <span class="comment">// List initialization within a constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x&#123;<span class="number">42</span>&#125;;            <span class="comment">// Direct list initialization</span></span><br><span class="line">    <span class="type">int</span> y = &#123;<span class="number">42</span>&#125;;         <span class="comment">// Copy list initialization</span></span><br><span class="line"></span><br><span class="line">    Point p&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;      <span class="comment">// List initialization of an aggregate</span></span><br><span class="line">    Rectangle r&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">10</span>&#125;; <span class="comment">// List initialization calling a constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>法语学习笔记 法语语音 [a], [ɛ], [e]常见的字母和组合</title>
    <url>/2024/10/13/%E6%B3%95%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B3%95%E8%AF%AD%E8%AF%AD%E9%9F%B3-a-e-e-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E6%AF%8D%E5%92%8C%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="a">[a]</h1>
<h2 id="a-à-â">a, à, â</h2>
<ul>
<li>papa [papa]</li>
<li>sa [sa]</li>
<li>tas [ta]</li>
<li>la [la]</li>
<li>à [a]</li>
<li>âne [an]</li>
<li>pâle [pal]</li>
</ul>
<p>不带拼写符号的e在词末不发音</p>
<p>大多数辅音字母在词末不发音，qclrf除外</p>
<h2 id="emm-enn"><strong>e</strong>mm, <strong>e</strong>nn</h2>
<ul>
<li>femme [fam]</li>
</ul>
<h1 id="ɛ">[ɛ]</h1>
<h2 id="e在闭音节中">e在闭音节中</h2>
<ul>
<li>mer [mɛr]</li>
<li>mec [mɛk]</li>
<li>sek [sɛk]</li>
<li>sel [sɛl]</li>
</ul>
<p>闭音节：读音中以辅音音素结尾的音节</p>
<h2 id="e在两个相同辅音字母之前">e在两个相同辅音字母之前</h2>
<ul>
<li>messe [mɛs]</li>
<li>nette [nɛt]</li>
<li>cette [cɛt]</li>
</ul>
<h2 id="ê-è-ë">ê, è, ë</h2>
<ul>
<li>sève [sɛv]</li>
<li>même [mɛm]</li>
<li>pèle [pɛl]</li>
<li>mère [mɛr]</li>
<li>Noël [nɔɛl]</li>
</ul>
<h2 id="ai-aî-ei">ai, aî, ei</h2>
<ul>
<li>mai [mɛ]</li>
<li>aime [ɛm]</li>
<li>fraîche [frɛʃ]</li>
<li>naît [nɛ]</li>
<li>Seine [sɛn]</li>
<li>neige [nɛʒ]</li>
</ul>
<h2 id="et在词末">et在词末</h2>
<ul>
<li>navet [navɛ]</li>
<li>filet [filɛ]</li>
<li>guichet [giʃɛ]</li>
<li>valet [valɛ]</li>
</ul>
<h1 id="e">[e]</h1>
<h2 id="é">é</h2>
<ul>
<li>été [ete]</li>
<li>né [ne]</li>
<li>thé [te]</li>
<li>café [kafe]</li>
</ul>
<p>h在法语中都是不发音的</p>
<h2 id="er-ez在词末">er, ez在词末</h2>
<ul>
<li>visiter [vizite]</li>
<li>léger [leʒe]</li>
<li>parler [parle]</li>
<li>répéter [repete]</li>
<li>chez [ʃe]</li>
<li>nez [ne]</li>
</ul>
<h2 id="es在少数单音节词中">es在少数单音节词中</h2>
<ul>
<li>les [le]</li>
<li>des [de]</li>
<li>ces [se]</li>
<li>mes [me]</li>
</ul>
<p>单音节词：单词中只有一个音节</p>
<h1
id="笔记中用到的音标符号对应的html编码">笔记中用到的音标符号对应的HTML编码</h1>
<table>
<tbody>
<tr>
<td>ɔ</td>
<td>ɛ</td>
<td>ʒ</td>
<td>ʃ</td>
</tr>
<tr>
<td>&amp;#596;</td>
<td>&amp;#603;</td>
<td>&amp;#658;</td>
<td>&amp;#643;</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>french</tag>
      </tags>
  </entry>
  <entry>
    <title>法语语音 eu, oeu字母组合的读音规则（涉及元音œ, ø）</title>
    <url>/2024/10/18/%E6%B3%95%E8%AF%AD%E8%AF%AD%E9%9F%B3-eu-oeu%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E7%9A%84%E8%AF%BB%E9%9F%B3%E8%A7%84%E5%88%99%EF%BC%88%E6%B6%89%E5%8F%8A%E5%85%83%E9%9F%B3oe-o%EF%BC%89/</url>
    <content><![CDATA[<h1 id="œ">[œ]</h1>
<h2 id="eu-oeu在闭音节中">eu, oeu在闭音节中</h2>
<ul>
<li>heure</li>
<li>fleur</li>
<li>fleuve</li>
<li>labeur</li>
<li>tricheur</li>
<li>immeuble</li>
<li>soeur</li>
<li>coeur</li>
<li>boeuf （单数）</li>
<li>oeuf (单数)</li>
</ul>
<h2 id="eu-oeu在词首或词中">eu, oeu在词首或词中</h2>
<ul>
<li>beurrer</li>
<li>déjeuner</li>
<li>aveugler</li>
<li>h<strong>eu</strong>reux</li>
<li>oeuvrer</li>
<li>désoeuvrer</li>
</ul>
<h1 id="ø">[ø]</h1>
<h2 id="eu-oeu在词末开音节">eu, oeu在词末开音节</h2>
<ul>
<li>peu</li>
<li>deux</li>
<li>ceux</li>
<li>jeux</li>
<li>queue</li>
<li>bleue</li>
<li>voeux</li>
<li>noeud</li>
<li>oeufs （复数）</li>
<li>boeufs （复数）</li>
</ul>
<h2 id="eu在dtzʒ前">eu在[d],[t],[z],[ʒ]前</h2>
<ul>
<li>jeudi</li>
<li>émeute</li>
<li>heur<strong>eu</strong>se</li>
<li>maubeuge</li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>french</tag>
      </tags>
  </entry>
  <entry>
    <title>法语语音 元音i,u,y常见的字母和组合</title>
    <url>/2024/10/18/%E6%B3%95%E8%AF%AD%E8%AF%AD%E9%9F%B3-%E5%85%83%E9%9F%B3i-u-y%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E6%AF%8D%E5%92%8C%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="i">[i]</h1>
<h2 id="i-î-ï">i î ï</h2>
<ul>
<li>si [si]</li>
<li>kaki [kaki]</li>
<li>qui [ki]</li>
<li>pile [pil]</li>
<li>île [il]</li>
<li>naïf [naif]</li>
<li>maïs [mais]</li>
</ul>
<h2 id="y">y</h2>
<ul>
<li>type [tip]</li>
<li>Fanny [fani]</li>
</ul>
<h1 id="u">[u]</h1>
<h2 id="ou-où-oû">ou, où, oû</h2>
<ul>
<li>loup [lu]</li>
<li>vous [vu]</li>
<li>avoue [avwe]</li>
<li>pousse [pus]</li>
<li>où [u]</li>
<li>coût [ku]</li>
<li>soûle [sul]</li>
<li>voûte [vut]</li>
</ul>
<h1 id="y-1">[y]</h1>
<p>u, û</p>
<ul>
<li>tu [ty]</li>
<li>salut [saly]</li>
<li>vu [vy]</li>
<li>sûr [syr]</li>
<li>mûraie [myrɛ]</li>
<li>flûte [flyt]</li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>french</tag>
      </tags>
  </entry>
  <entry>
    <title>法语语音 辅音f,l,m,n,v,r,p,b,t,d,k,g,s,z,ʃ,ʒ常见的字母和组合</title>
    <url>/2024/10/18/%E6%B3%95%E8%AF%AD%E8%AF%AD%E9%9F%B3-%E8%BE%85%E9%9F%B3f-l-m-n-v-r-p-b-t-d-k-g-s-z-%CA%83-%CA%92%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E6%AF%8D%E5%92%8C%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="f">[f]</h1>
<h2 id="f-ff">f, ff</h2>
<ul>
<li>flamme [flam]</li>
<li>difficile [difisil]</li>
<li>chef [ʃɛf]</li>
<li>fil [fil]</li>
</ul>
<h2 id="ph">ph</h2>
<ul>
<li>physique [fizik]</li>
<li>pharmacie [farmasi]</li>
</ul>
<h1 id="l">[l]</h1>
<p>l, ll</p>
<ul>
<li>fil [fil]</li>
<li>cil [sil]</li>
<li>lilas [lila]</li>
<li>Lille [lil]</li>
</ul>
<h1 id="m">[m]</h1>
<p>m, mm</p>
<ul>
<li>mal [mal]</li>
<li>mis [mi]</li>
<li>mille [mil]</li>
<li>mec [mɛk]</li>
</ul>
<h1 id="n">[n]</h1>
<p>n, nn</p>
<ul>
<li>minute [minyt]</li>
<li>Anne [an]</li>
<li>Fanny [fani]</li>
<li>natte [nat]</li>
<li>nid [ni]</li>
</ul>
<h1 id="v">[v]</h1>
<p>v</p>
<ul>
<li>valise [valiz]</li>
<li>visite [vizit]</li>
<li>vitesse [vitɛs]</li>
<li>veine [vɛn]</li>
<li>fève [fɛv]</li>
<li>rivalité [rivalite]</li>
</ul>
<p># [r] r, rr</p>
<ul>
<li>rare [rar]</li>
<li>lir [lir]</li>
<li>race [ras]</li>
<li>route [rut]</li>
<li>russe [rys]</li>
<li>courir [kurir]</li>
</ul>
<h1 id="p">[p]</h1>
<p>p, pp</p>
<ul>
<li>papa</li>
<li>paix</li>
<li>pure</li>
<li>nappe</li>
<li>carpe</li>
<li>tulipe</li>
</ul>
<h1 id="b">[b]</h1>
<p>b, bb</p>
<ul>
<li>bus</li>
<li>abbé</li>
<li>barbe</li>
<li>banane</li>
<li>arabe</li>
<li>cabane</li>
</ul>
<h1 id="t">[t]</h1>
<p>t, tt, th</p>
<ul>
<li>ta</li>
<li>était</li>
<li>thé</li>
<li>cette</li>
<li>pirate</li>
<li>patate</li>
</ul>
<h1 id="d">[d]</h1>
<p>d, dd</p>
<ul>
<li>date</li>
<li>additif</li>
<li>boude</li>
<li>gardait</li>
<li>maladie</li>
<li>rapide</li>
</ul>
<h1 id="k">[k]</h1>
<h2 id="c-cc-a-o-u-以及-c辅音字母">c, cc + a, o, u 以及 c+辅音字母</h2>
<ul>
<li>carte</li>
<li>caisse</li>
<li>coupe</li>
<li>couler</li>
<li>culture</li>
<li>cube</li>
<li>classe</li>
<li>classe</li>
<li>acte</li>
</ul>
<h2 id="k-ck">k, ck</h2>
<ul>
<li>kaki</li>
<li>ticket</li>
<li>kiwi</li>
<li>kermesse</li>
</ul>
<h2 id="c和q在词末">c和q在词末</h2>
<ul>
<li>lac</li>
<li>sec</li>
<li>coq</li>
<li>cinq</li>
</ul>
<h2 id="qu">qu</h2>
<ul>
<li>qui</li>
<li>quel</li>
<li>qualité</li>
<li>étiquette</li>
<li>laque</li>
<li>boutique</li>
</ul>
<h2 id="ks">[ks]</h2>
<p>cc + e,i</p>
<ul>
<li>accès</li>
<li>accident</li>
</ul>
<h1 id="g">[g]</h1>
<h2 id="g-aou-以及-g-辅音字母">g + a,o,u 以及 g + 辅音字母</h2>
<ul>
<li>gare</li>
<li>goûter</li>
<li>légume</li>
<li>glace</li>
<li>règle</li>
</ul>
<h2 id="g在少数词词末">g在少数词词末</h2>
<ul>
<li>zigzag</li>
</ul>
<h2 id="gu-eiy">gu + e,i,y</h2>
<ul>
<li>guérir</li>
<li>guerre</li>
<li>guide</li>
<li>Guy</li>
</ul>
<h1 id="s">[s]</h1>
<h2
id="当字母s不在两个元音字母之间的时候以及两个s相连的时候">当字母s不在两个元音字母之间的时候，以及两个s相连的时候</h2>
<ul>
<li>sac</li>
<li>salle</li>
<li>kyste</li>
<li>salive</li>
<li>fasse</li>
<li>russe</li>
</ul>
<h2 id="c在字母eiy前">c在字母e,i,y前</h2>
<ul>
<li>cette</li>
<li>vice</li>
<li>ici</li>
<li>civile</li>
<li>cycle</li>
<li>bicyclette</li>
</ul>
<h2 id="ç在aou前">ç在a,o,u前</h2>
<ul>
<li>ça [sa]</li>
<li>façon [fasɔ̃]</li>
<li>déçu [desy]</li>
<li>français [frɑ̃sɛ]</li>
</ul>
<h2 id="sc在ei之前">sc在e,i之前</h2>
<ul>
<li>scène [sɛn]</li>
<li>scie [si]</li>
</ul>
<h1 id="z">[z]</h1>
<h2 id="z-1">z</h2>
<ul>
<li>zèle</li>
<li>zigzag</li>
<li>zazou</li>
<li>seize</li>
<li>bizarre</li>
<li>magazine</li>
</ul>
<h2 id="s在两个元音字母之间">s在两个元音字母之间</h2>
<ul>
<li>visite [vizit]</li>
<li>base [baz]</li>
<li>nasal [nazal]</li>
<li>visa [viza]</li>
<li>hésiter [ezite]</li>
<li>musée [myze]</li>
</ul>
<h1 id="ʃ">[ʃ]</h1>
<p>ch</p>
<ul>
<li>Chine [ʃin]</li>
<li>chasse [ʃas]</li>
<li>choux [ʃu]</li>
<li>chaîne [ʃɛn]</li>
<li>échapper [eʃape]</li>
<li>chez [ʃe]</li>
</ul>
<h1 id="ʒ">[ʒ]</h1>
<h2 id="j">j</h2>
<ul>
<li>déjà</li>
<li>journal</li>
<li>juste</li>
<li>joue</li>
<li>naja</li>
</ul>
<h2 id="g在eiy前">g在e,i,y前</h2>
<ul>
<li>geste</li>
<li>page</li>
<li>gilet</li>
<li>gilet</li>
<li>girafe</li>
<li>sagesse</li>
<li>fougère</li>
</ul>
<h1 id="发音规则补充">发音规则补充</h1>
<p>大部分辅音字母在词末不发音，但是如果词末是不发音的字母e，那么e之前的辅音字母就要发音。</p>
<ul>
<li>kyste [kist]</li>
<li>guide [gid]</li>
<li>caisse [kɛs]</li>
<li>camarade [kamarad]</li>
</ul>
<hr />
<p>连个相同的辅音字母合读一个音</p>
<ul>
<li>pelle [pɛl]</li>
<li>Anne [an]</li>
<li>nasse [nas]</li>
<li>quitter [kite]</li>
</ul>
<hr />
<p>法语的中印一般落在单词或词组的最后一个音节上（因此音标中不标出重音位置）；
法语的重音在整个词中分配较平均，重读音节与非重读音节差别不大。</p>
<hr />
<p>[p], [t], [k] - 在元音前与元音进行拼读时不送气 - 在音节末时要送气</p>
<h1 id="用到的鼻化元音的html编码">用到的鼻化元音的html编码</h1>
<table>
<tbody>
<tr>
<td>ɑ̃</td>
<td>&amp;#593;&amp;#x303;</td>
</tr>
<tr>
<td>ɛ̃</td>
<td>&amp;#x25B;&amp;#x303;</td>
</tr>
<tr>
<td>ɔ̃</td>
<td>&amp;#x25B;&amp;#x303;</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>french</tag>
      </tags>
  </entry>
</search>
